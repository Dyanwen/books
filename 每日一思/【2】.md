### 实现deepClone

- 使用 Reflect.ownKeys 方法，能够遍历对象的不可枚举属性和Symbol类型
- 当参数为Date或者RegExp的时候，直接返回新创建的对象
- 利用object.getOwnPropertyDescriptor方法可以获取对象的所有属性，以及对象的特性，结合Object.create方法创建一个新对象，并传入原对象的圆形链
- 利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏

```js
const isComplexDataType = obj => {
    return (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)
}

const deepClone = (obj, hash = new WeakMap()) => {
    if (obj.constructor == Date) {
        return new Date(obj)
    }
    if (obj.constructor == RegExp) {
        return new RegExp(obj);
    }
    if (hash.has(obj)) {
        return hash.get(obj)
    }

    let allDesc = Object.getOwnPropertyDescriptor(obj);//获取对象的所有属性
    let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);//创建一个新对象，并继承传入原对象的原形链

    hash.set(obj, cloneObj);
    
    for (const key of Reflect.ownKeys(obj)) {
        cloneObj[key] = (isComplexDataType(obj) && typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : Reflect.get(key);
    }
}
```