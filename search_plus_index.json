{"./":{"url":"./","title":"介绍","keywords":"","body":"晨希-整理目录 JavaScript 核心原理解析 图解 Google V8 常用工具 日常总结 2022.01.11 [x] 开篇词 | 如何学习谷歌高性能 JavaScript 引擎 V8？ [x] 01 | V8 是如何执行一段 JavaScript 代码的？ 2022.01.12 [x] 02 | 函数即对象：一篇文章彻底搞懂 JavaScript 的函数特点 [x] 03 ｜快属性和慢属性：V8 采用了哪些策略提升了对象属性的访问速度？ [x] 04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？ [x] 05｜原型链：V8是如何实现对象继承的？ [ ] 06｜作用域链：V8是如何查找变量的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 20:48:44 "},"JavaScript核心原理解析/":{"url":"JavaScript核心原理解析/","title":"JavaScript核心原理解析","keywords":"","body":"JavaScript核心原理解析 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/00.html":{"url":"JavaScript核心原理解析/00.html","title":"开篇词 | 如何解决语言问题？","keywords":"","body":"开篇词 | 如何解决语言问题？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/01.html":{"url":"JavaScript核心原理解析/01.html","title":"01 | delete 0：JavaScript中到底有什么是可以销毁的","keywords":"","body":"01 | delete 0：JavaScript中到底有什么是可以销毁的 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/02.html":{"url":"JavaScript核心原理解析/02.html","title":"02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质","keywords":"","body":"02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/03.html":{"url":"JavaScript核心原理解析/03.html","title":"03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题","keywords":"","body":"03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/04.html":{"url":"JavaScript核心原理解析/04.html","title":"04 | export default function() {}：你无法导出一个匿名函数表达式","keywords":"","body":"04 | export default function() {}：你无法导出一个匿名函数表达式 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/05.html":{"url":"JavaScript核心原理解析/05.html","title":"05 | for (let x of [1, 2, 3]) ...：for循环并不比使用函数递归节省开销","keywords":"","body":"05 | for (let x of [1, 2, 3]) ...：for循环并不比使用函数递归节省开销 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/06.html":{"url":"JavaScript核心原理解析/06.html","title":"06 | x/ break x; 搞懂如何在循环外使用break，方知语句执行真解","keywords":"","body":"06 | x/ break x; 搞懂如何在循环外使用break，方知语句执行真解 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/07.html":{"url":"JavaScript核心原理解析/07.html","title":"07 | ${1} ：详解JavaScript中特殊的可执行结构","keywords":"","body":"07 | ${1} ：详解JavaScript中特殊的可执行结构 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/08.html":{"url":"JavaScript核心原理解析/08.html","title":"08 | x => x：函数式语言的核心抽象：函数与表达式的同一性","keywords":"","body":"08 | x => x：函数式语言的核心抽象：函数与表达式的同一性 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/09.html":{"url":"JavaScript核心原理解析/09.html","title":"09 | (...x)：不是表达式、语句、函数，但它却能执行","keywords":"","body":"09 | (...x)：不是表达式、语句、函数，但它却能执行 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/10.html":{"url":"JavaScript核心原理解析/10.html","title":"10 | x = yield x：迭代过程的“函数式化”","keywords":"","body":"10 | x = yield x：迭代过程的“函数式化” Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/11.html":{"url":"JavaScript核心原理解析/11.html","title":"11 | throw 1; ：它在“最简单语法榜”上排名第三","keywords":"","body":"11 | throw 1; ：它在“最简单语法榜”上排名第三 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/12.html":{"url":"JavaScript核心原理解析/12.html","title":"12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false","keywords":"","body":"12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/13.html":{"url":"JavaScript核心原理解析/13.html","title":"13 | new X：从构造器到类，为你揭密对象构造的全程","keywords":"","body":"13 | new X：从构造器到类，为你揭密对象构造的全程 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/14.html":{"url":"JavaScript核心原理解析/14.html","title":"14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲","keywords":"","body":"14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/15.html":{"url":"JavaScript核心原理解析/15.html","title":"15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类","keywords":"","body":"15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/16.html":{"url":"JavaScript核心原理解析/16.html","title":"16 | [a, b] = {a, b}：让你从一行代码看到对象的本质","keywords":"","body":"16 | [a, b] = {a, b}：让你从一行代码看到对象的本质 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/17.html":{"url":"JavaScript核心原理解析/17.html","title":"17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着","keywords":"","body":"17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/18.html":{"url":"JavaScript核心原理解析/18.html","title":"18 | a + b：动态类型是灾难之源还是最好的特性？（上）","keywords":"","body":"18 | a + b：动态类型是灾难之源还是最好的特性？（上） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/19.html":{"url":"JavaScript核心原理解析/19.html","title":"19 | a + b：动态类型是灾难之源还是最好的特性？（下）","keywords":"","body":"19 | a + b：动态类型是灾难之源还是最好的特性？（下） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/20.html":{"url":"JavaScript核心原理解析/20.html","title":"20 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（上）","keywords":"","body":"20 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（上） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/21.html":{"url":"JavaScript核心原理解析/21.html","title":"21 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（下）","keywords":"","body":"21 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（下） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/22.html":{"url":"JavaScript核心原理解析/22.html","title":"22 | new Function('x = 100')(); ：函数的类化是对动态与静态系统的再次统一","keywords":"","body":"22 | new Function('x = 100')(); ：函数的类化是对动态与静态系统的再次统一 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/23.html":{"url":"JavaScript核心原理解析/23.html","title":"加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？","keywords":"","body":"加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/24.html":{"url":"JavaScript核心原理解析/24.html","title":"加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？","keywords":"","body":"加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/25.html":{"url":"JavaScript核心原理解析/25.html","title":"加餐 | 让JavaScript运行起来","keywords":"","body":"加餐 | 让JavaScript运行起来 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/26.html":{"url":"JavaScript核心原理解析/26.html","title":"结束语 | 愿你能做一个真正“懂”的程序员","keywords":"","body":"结束语 | 愿你能做一个真正“懂”的程序员 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/":{"url":"图解GoogleV8/","title":"图解GoogleV8","keywords":"","body":"图解GoogleV8 [ ] 闭包 [ ] 作用域链 [ ] 原型链 [ ] 两个链之间的区别 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 11:28:36 "},"图解GoogleV8/00.html":{"url":"图解GoogleV8/00.html","title":"开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？","keywords":"","body":"开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？ 什么是v8? V8是js虚拟机的一种,我们可以简单的把js虚拟机理解成一个翻译程序,将人类能够理解的编程语言js,翻译成能够理解的机器语言. V8是早于其他虚拟机引入了惰性编译,内联缓存,隐藏类等机制,进一步优化了js代码的编译执行效率 V8的主要功能就是结合js语言的特性和本质来编译执行它,通过深入地学习V8,你对js语言本质和设计思想会有很直观的感受. 如何学习V8? js 借鉴了很多语言特性:比如C语言的基本语法,java的类型系统和内存管理,scheme的函数作为一蹦公民,还有self基于原型的继承机制 V8是js的实现,在学习V8工作原理时,我们需要额外关注js这些独特的设计思想和特性背后的实现,比如,为了实现函数是一等公民的特性,js采取了鲫鱼对象的策略,再比如为了实现原型继承,V8为每个对象引入了proto属性 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 10:08:33 "},"图解GoogleV8/01.html":{"url":"图解GoogleV8/01.html","title":"01 | V8是如何执行一段JavaScript代码的？","keywords":"","body":"01 | V8是如何执行一段JavaScript代码的？ 什么是v8? v8是一个由google开发的js引擎,目前用在chrome浏览器和node.js中,其核心功能是执行易于人类理解的js代码 高级代码为什么需要先编译在执行? 主要核心流程分为编译和执行两步 首先需要将js代码转换成低级中间代码或者机器能够理解的机器代码 然后执行转换后的代码并输出执行结果 cpu只能识别机器指令,但是对于程序员来说,二进制代码难以阅读和记忆,于是我们将二进制指令集转换为人类可以识别和记忆的富符号,这就是汇编指令集. 汇编语言的不好之处 不同的cpu有着不同的指令集 在编写汇编代码的时候,我们需要了解和处理器架构相关的硬件知识.比如你需要使用寄存器,内存,操作cpu等.我们在编写应用的时候,只想专心处理业务逻辑,并不想要过多理会这些处理器架构相关的细节 因此我们需要一种屏蔽了计算机架构细节的语言,能适应多种不同cpu架构的语言,只专心处理业务逻辑的语言,比如c,c++,java,c#,Python,js等这些高级语言 执行高级语言的方法 解释执行:首先将输入的源代码通过解析器编译成中间代码,之后直接使用解释器解释执行中间代码,然后直接输出结果,具体流程如下 编译执行:采用这种方式,也需要先将源代码转换成中间代码,然后我们的编译器再将中间代码转换成机器代码.通常编译成的机器代码是以二进制文件形式存储的,需要执行这段程序的时候直接执行二进制文件就可以了,还可以使用虚拟机将编译后的机器代码保存在内存中,然后直接执行内存中的二进制代码 不同的浏览器对js这一门语言的实现也是不同的,例如safari使用的是jscore虚拟机,firefox使用了traceMonkey虚拟机,而chrome则使用了v8虚拟机 v8是怎么执行js代码的? 实际上v8并没有采用某种单一的技术,而是混合编译执行和解释执行这两种手段,我们把这种混合使用编译器和解释器的技术称为jit技术 这是一种权衡策略,因为这两种方式都有各自的优缺点, 解释器执行的启动速度快,但是执行时的速度慢 编译执行的启动速度慢,但是执行时的速度快 v8启动执行js之前,他需要准备执行js时所需要的一些基础环境,包括堆栈空间,全局作用域,消息循环系统,内置函数等. js全局执行上下文就包括了执行过程中的全局信息,比如一些内置函数,全局变量等信息 全局作用域包含了一些全局变量,在执行过程中的数据都需要存放在内存中 v8采用了经典的堆和栈的内存管理模式,所以v8还需要初始化内存中的堆和栈机构 还需要初始化消息循环系统,消息循环系统包含了消息驱动器和消息队列,它如同v8的心脏,不断接受消息并决策如何处理消息 相信你注意到了，我们在解释器附近画了个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器会在后 台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进 制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么V8会优先选择 优化之后的二进制代码，这样代码的执行速度就会大幅提升。 不过，和静态语言不同的是，JavaScript是一种非常灵活的动态语言，对象的结构和属性是可 以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在 执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时 候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解 释执行。 理解了这一点，我们就可以来深入分析V8执行一段JavaScript代码所经历的主要流程了，这 包括了: 解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译 执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺 点，V8采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执 行频率超过一个值，那么V8就会采用优化编译器将其编译成执行效率更加高效的机器代码。 因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段， 第一种是将高级代码转换为二进制代码，再让计算机去执行; 另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。 V8是由Google开发的开源JavaScript引擎，也被称为虚拟机，模拟实际计算机各种功能来实 现代码的编译和执行。那么，要想搞清楚V8内部的工作流程和原理，我们可以从分析计算机 对语言的编译和执行过程入手。 初始化基础环境 解析源码生成AST和作用域 依据AST和作用域生成字节码 解释执行字节码 监听热点代码 优化热点代码为二进制的机器代码 反优化热点代码为二进制的机器代码 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 20:53:57 "},"图解GoogleV8/02.html":{"url":"图解GoogleV8/02.html","title":"02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点","keywords":"","body":"02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点 什么是js中的对象?它和面向对象语言中的“对象”有什么区别? js是一门基于对象的语言,可以说,js中大部分的内容都是由对象构成的,诸如函数,数组,也可以说js是建立在对象之上的语言 这些对象在运行时可以动态修改其内容,这就造就了js的超级灵活特性. 虽然js是基于对象设计的,但是它却不是一门面向对象的语言,因为面向对象语言天生支持封装,继承,多态,但是js并没有直接提供多态的支持,因此要在js中使用多态并不是一件容易的事 js中实现继承的方式,只是在对象中添加一个称为原型的属性,把继承的对象通过原型链接起来,就实现了继承,我们把这种继承方式称为基于言行链继承 对象的属性值有三种类型: 原始类型:null,undefined,boolean,number,string,bigint,symbol 对象类型 函数类型 函数到底关联了哪些内容? 函数作为一个对喜庆,它有自己的属性和值,所以函数关联了基础的属性和值 函数之所以称为特殊的对象,这个特殊的地方是函数可以“被调用”,所以一个函数被调用事,它还需要关联相关的执行上下文 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 11:28:22 "},"图解GoogleV8/03.html":{"url":"图解GoogleV8/03.html","title":"03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？","keywords":"","body":"03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？ js中的对象是由一组组属性和值的集合,从js语言的角度来看,js对象像一个字典,字符串作为键名,任意对象可以作为键值,可以通过键名读取键值 然而在V8实现对象存储时,并没有完全采用字段的存储方式,这主要是出于性能的考量,因为字典是非线性的数据结构,查询效率会低于线性的数据结构,V8为了提升存储和查找效率,采用了一套复杂的存储策略 function Foo(property_num,element_num){ for(let i = 0;i 因为js中的对象是由一组组属性和值组成的,所以最简单的方式是使用一个字典来保存属性和值,但是由于字典是非线性结构,所以使用如果使用字典,读取效率会大大降低 为了提升查找效率,V8在对象中添加了两个隐藏属性,排序属性和常规属性,指向了elements对象,在elements对象中,会按照顺序存放排序属性.properties属性则指向了properties对象,在properties对象中,会按照创建时的顺序保存常规属性 通过引入这两个属性,加速了V8查找属性的速度,为了更快进一步提升查找效率,V8还实现了内置内属性的策略,当常规属性少于一定数量时,V8就会将这些常规属性直接写进对象中,这样又节省了一个中间步骤 但是如果对象中的属性过多时,或者存在反复田间或者删除属性的操作,那么V8就会将线性的存储模式降级为非线性的字典存储模式,这样虽然降低了查找速度,但是却提升了修改对象的属性的速度. Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 14:43:25 "},"图解GoogleV8/04.html":{"url":"图解GoogleV8/04.html","title":"04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？","keywords":"","body":"04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？ 函数声明和函数表达式的区别 函数表达式是在表达式语句中使用 function 的,最典型的表达式是 a=b 这种形式,因为函数也是一个对象,我们把“a=function(){}”这种方式称为函数表达式 在函数表达式中,可以省略函数名称,从而创建匿名函数 一个函数表达式可以被用作一个即时调用的函数表达式--IIFE // 函数声明 function a() { // ... } // 函数表达式 const b = function () { // ... }; 执行过程 表达式就是表示值的式子,而语句是操作值的式子 在变量提升阶段,V8 并不会执行赋值的表达式,该阶段只会分析基础的语句,比如变量的定义,函数的声明 var x = 5; // 会执行两步操作: var x = undefined; //编译阶段完成的,也就是变量提升阶段完成的 x = 5; // 表达式,所有的表达式都是在执行阶段完成 在变量提升阶段,V8 将这些变量存放在作用域中,还会给他们赋一个默认的 undefined 值,所以在定义一个普通的变量之前,使用该变量,那么该变量的值就是 undefined 现在我们知道,表达式是不会在编译阶段执行的,那么函数声明是表达式还是语句呢? function foo(){ console.log('foo); } 执行上面这段代码,他并没有输出任何内容,所以可以肯定,函数声明并不是一个表达式, 而是一个语句.V8 在变量提升阶段,如果遇到函数声明,那么 V8 同样会对该函数声明执行变量提升操作 函数也是一个对象,所以在编译阶段,V8 就会将整个函数对象提升到作用域中,并不是给该函数名称赋一个 undefined. V8 是怎么处理函数表达式的? 在一个表达式中使用 function 来定义一个函数,那么就把该函数称为函数表达式. 函数立即表达式也是一个表达式,所以 V8 在编译阶段,并不会为该表达式创建函数对象,这样的一个好处就是不会污染全局环境,函数和函数内部的变量都不会被其他部分的代码访问到. V8 对于提升函数和提升变量的策略是不同的，如果提升了一个变量，那么 V8 在将变量提 升到作用域中时，还会为其设置默认值 undeifned，如果是函数声明，那么 V8 会在内存中创建 该函数对象，并提升整个函数对象 函数表达式也是表达式的一种，在编译阶段，V8 并不会将表达式中的函数对象提升到全局作 用域中，所以无法在函数表达式之前使用该函数。函数立即表达式是一种特别的表达式，主 要用来封装一些变量、函数，可以起到变量隔离和代码隐藏的作用，因此在一些大的开源项 目中有广泛的应用 var n = 1; (function () { n=100, console.log(n)//100 }()) console.log(n)//100 var n = 1 function foo() { n = 100; console.log(n)//100 } console.log(n)//1 foo() Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 18:47:26 "},"图解GoogleV8/05.html":{"url":"图解GoogleV8/05.html","title":"05｜原型链：V8是如何实现对象继承的？","keywords":"","body":"05｜原型链：V8是如何实现对象继承的？ 继承就是一个对象可以访问另外一个对象中的属性和方法,在js中,我们通过原型和原型链的方式来实现了继承特性 继承的两种方式: 基于类的实现 基于原型的实现 js仅仅在对象中引入了一个原型的属性,就实现了语言的继承机制,基于原型的继承省去了很多基于类继承的繁文缛节,简洁而优美 原型继承是如何实现的? js中的每个对象都包涵一个隐藏属性proto,我们就把该隐藏属性proto称为该对象的原型,proto只想了内存中的另一个对象,我们就把proto指向的对象称为该对象的原型对象,那么该对象就可以直接访问其原型对象的方法或者属性 原型链 查找属性的路径称为原型链,它像一个链条一样,将几个原型链接了起来 var animal = { type:'default', color:'default', getInfo:function () { return `type is ${this.type},color is ${this.color}`; } } var dog = { type:'dog', color:'black' } dog.__proto__= animal; var a = dog.getInfo(); console.log(a)//type is dog,color is black 通常情况下,隐藏属性是不能使用js来直接与之交互的. 虽然现代浏览器都开了一个口子,让js可以访问隐藏属性proto,但是在实际项目中,我们不应该直接通过proto来访问或者修改该属性,其主要原因有两个: 首先,这是隐藏属性,并不是标准定义的 其次,使用该属性会造成严重的性能问题 所以，在JavaScript中，是使用new加上构造函数的这种组合来创建对象和实现对象的继承 [info] 原型链是沿着对象的原型一级一级来查找属性的 作用域链 [info] 作用域链是沿着函数的作用域一级一级来查找变量的 构造函数是怎么创建对象的? function DogFactory(type,color) { this.type = type; this.color = color; } var dog = new DogFactory('dog', 'red'); 其实当V8执行上面这段代码时，V8会在背后悄悄地做了以下几件事情，模拟代码如下所示 var dog = {}; dog.__proto__=DogFactory.prototype DogFactory.call(dog,'dog','red') 为了加深你的理解，我画了上面这段代码的执行流程图 由上图可知,执行流程分为三步: 首先创建一个空白对象 然后将DogFactory的prototype属性设置为dog的原型对象,这就是给dog对象设置原型对象的关键一步, 最后,在使用dog来调用DogFactory,这时候DogFactory函数中的this就指向了对象dog,然后在DogFactory函数中,利用this对对象dog执行属性填充属性,最终就创建了dog对象 构造函数怎么实现继承? 函数除了拥有name和code这两个隐藏属性之外,还有另一个prototype属性 每个函数对象中都有一个公开的prototype属性，当你将这个函数作为构造函数来创建一个新 的对象时，新创建对象的原型对象就指向了该函数的prototype属性。当然了，如果你只是正 常调用该函数，那么prototype属性将不起作用 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 20:05:00 "},"图解GoogleV8/06.html":{"url":"图解GoogleV8/06.html","title":"06｜作用域链：V8是如何查找变量的？","keywords":"","body":"06｜作用域链：V8是如何查找变量的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/07.html":{"url":"图解GoogleV8/07.html","title":"07｜类型转换：V8是怎么实现1+“2”的？","keywords":"","body":"07｜类型转换：V8是怎么实现1+“2”的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/08.html":{"url":"图解GoogleV8/08.html","title":"08｜答疑：如何构建和使用V8的调试工具d8？","keywords":"","body":"08｜答疑：如何构建和使用V8的调试工具d8？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/09.html":{"url":"图解GoogleV8/09.html","title":"09 | 运行时环境：运行JavaScript代码的基石","keywords":"","body":"09 | 运行时环境：运行JavaScript代码的基石 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/10.html":{"url":"图解GoogleV8/10.html","title":"10 | 机器代码：二进制机器码究竟是如何被CPU执行的？","keywords":"","body":"10 | 机器代码：二进制机器码究竟是如何被CPU执行的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/11.html":{"url":"图解GoogleV8/11.html","title":"11 | 堆和栈：函数调用是如何影响到内存布局的？","keywords":"","body":"11 | 堆和栈：函数调用是如何影响到内存布局的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/12.html":{"url":"图解GoogleV8/12.html","title":"12 | 延迟解析：V8是如何实现闭包的？","keywords":"","body":"12 | 延迟解析：V8是如何实现闭包的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/13.html":{"url":"图解GoogleV8/13.html","title":"13 | 字节码（一）：V8为什么又重新引入字节码？","keywords":"","body":"13 | 字节码（一）：V8为什么又重新引入字节码？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/14.html":{"url":"图解GoogleV8/14.html","title":"14｜字节码（二）：解释器是如何解释执行字节码的？","keywords":"","body":"14｜字节码（二）：解释器是如何解释执行字节码的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/15.html":{"url":"图解GoogleV8/15.html","title":"15 | 隐藏类：如何在内存中快速查找对象属性？","keywords":"","body":"15 | 隐藏类：如何在内存中快速查找对象属性？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/16.html":{"url":"图解GoogleV8/16.html","title":"16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？","keywords":"","body":"16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/17.html":{"url":"图解GoogleV8/17.html","title":"17 | 消息队列：V8是怎么实现回调函数的？","keywords":"","body":"17 | 消息队列：V8是怎么实现回调函数的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/18.html":{"url":"图解GoogleV8/18.html","title":"18 | 异步编程（一）：V8是如何实现微任务的？","keywords":"","body":"18 | 异步编程（一）：V8是如何实现微任务的？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"常用工具/":{"url":"常用工具/","title":"常用工具","keywords":"","body":"常用工具 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"常用工具/00.html":{"url":"常用工具/00.html","title":"core-js 及垫片理念","keywords":"","body":"core-js 及垫片理念 core-js 是一个 JavaScript 标准库，它包含了 ECMAScript 2020 在内的多项特性的 polyfills，以及 ECMAScript 在 proposals 阶段的特性、WHATWG/W3C 新特性等 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:46:23 "},"常用工具/01.html":{"url":"常用工具/01.html","title":"Git 操作","keywords":"","body":"Git 操作 查看仓库的配置 git config --list --global(当前用户的所有仓库) git config --list --local(具体的某一个仓库) git config --list --system(对系统所有的登录的有效) 配置全局的 git 仓库 git config --global user.name \"Denise\" git config --global user.email 'deng.yanwen@icloud.com' 清除 git 配置 git config --unset --local user.name 建立 git 仓库 把已有的项目代码纳入 git 管理:git init 从远程新建项目, 然后 clone 下拉:git clone 修改之前的已提交的文件的名称 git mv readme readme.md 删除暂存区和本地工作目录的更改 git reset --hard 查看项目历史版本 git log --oneline(简洁的历史) git log -n2 --oneline git log --all (查看所有分支的提交历史) git 的核心对象:blob, tree, commit git cat-file -p , 查看 git 对象的内容 git cat-file -t , 查看 git 对象的类型 git cat-file -s , 查看 git 对象的大小 .git 文件中存放的内容 objects【文件夹】，存放所有的 git 对象，对象哈希值前两位是文件名，后 38 位作为对象文件名，可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看 HEAD 中存放指向当前分支所在的分支， config 当前 git 的配置文件 refs【文件夹】 heads 存放当前项目的所有分支 remotes 存放远程信息 tags 存放当前项目的所有分支 git branch -av 撤销操作 修改最后一次 commit 的信息：git commit --amend [danger] 注意: git log -p - 2: 查看最近两次提交历史的差异 git add -u: 将 git 已经跟踪的文件一起添加到暂存区 cp 原来的文件地址 需要拷贝到的地址: 拷贝文件 vi 文件名: 查看文件内容 mv 修改的文件的名称 改之后的文件名称 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 10:59:48 "},"常用工具/02.html":{"url":"常用工具/02.html","title":"本地仓库如何关联远程仓库","keywords":"","body":"本地仓库如何关联远程仓库 首先在远程仓库上建立一个空的项目 然后在本地新建一个项目，进入项目，执行命令git init,即为初始化本地的这个文件夹为一个git可以管理的仓库，这时候仓库会自动添加一个master分支 将本地仓库与远程仓库关联在一起，git remote add origin + 仓库地址 在新建本地代码之后，使用git push -u origin master将本地代码推送到远程仓库 [info] 注意:我们第一次push的时候,加上-u参数,Git就会把本地的master分支和远程的master分支进行关联起来,我们以后的push操作就不再需要加上-u参数了 之后就可以进行相关的代码操作了 [info] 注意：如果出现Git refusing to merge unrelated histories，解决方法为：git pull origin master后面跟上参数--allow-unrelated-histories Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 10:51:46 "},"日常总结/":{"url":"日常总结/","title":"日常总结","keywords":"","body":"日常总结 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "}}