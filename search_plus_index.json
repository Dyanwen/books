{"./":{"url":"./","title":"介绍","keywords":"","body":"晨希-整理目录 JavaScript 核心原理解析 图解 Google V8 常用工具 日常总结 2022.01.11 [x] 开篇词 | 如何学习谷歌高性能 JavaScript 引擎 V8？ [x] 01 | V8 是如何执行一段 JavaScript 代码的？ 2022.01.12 [x] 02 | 函数即对象：一篇文章彻底搞懂 JavaScript 的函数特点 [x] 03 ｜快属性和慢属性：V8 采用了哪些策略提升了对象属性的访问速度？ [x] 04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？ [x] 05｜原型链：V8是如何实现对象继承的？ [x] 06｜作用域链：V8是如何查找变量的？ 2022.01.13 [x] 07｜类型转换：V8是怎么实现1+“2”的？ [x] 08｜答疑：如何构建和使用V8的调试工具d8？ [x] 09 | 运行时环境：运行JavaScript代码的基石 2022.01.14 [x] 10 | 机器代码：二进制机器码究竟是如何被CPU执行的？ [x] 11 | 堆和栈：函数调用是如何影响到内存布局的？ [x] 12 | 延迟解析：V8是如何实现闭包的？ [x] 13 | 字节码（一）：V8为什么又重新引入字节码？ [x] 14｜字节码（二）：解释器是如何解释执行字节码的？ 2022.01.15 [x] 15 | 隐藏类：如何在内存中快速查找对象属性？ [x] 16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？ [x] 17 | 消息队列：V8是怎么实现回调函数的？ [x] 18 | 异步编程（一）：V8是如何实现微任务的？ 2022.01.18 [x] 开篇词 | 如何解决语言问题？.pdf [x] 01 | delete 0：JavaScript中到底有什么是可以销毁的 [x] 02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质 [x] 03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题 [x] 04 | export default function() {}：你无法导出一个匿名函数表达式 2022.01.122 [ ] Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 18:31:38 "},"JavaScript核心原理解析/":{"url":"JavaScript核心原理解析/","title":"JavaScript核心原理解析","keywords":"","body":"JavaScript核心原理解析 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/00.html":{"url":"JavaScript核心原理解析/00.html","title":"开篇词 | 如何解决语言问题？","keywords":"","body":"开篇词 | 如何解决语言问题？ 语言设计 结构化&&面向对象特性 部分动态语言特性 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-18 20:44:04 "},"JavaScript核心原理解析/01.html":{"url":"JavaScript核心原理解析/01.html","title":"01 | delete 0：JavaScript中到底有什么是可以销毁的","keywords":"","body":"01 | delete 0：JavaScript中到底有什么是可以销毁的 表达式的值,在es的规范中,称为引用 delete 0 单值表达式的运算结果返回那个“对象字面量”的单值 delete x归根结底是在删除一个表达式的,引用类型的结果,而不是在删除x表达式,或者这个删除表达式的值 delete 运算符尝试删除值数据时,会返回true,用于表示没有错误 delete 0的本质时删除一个表达式的值 delete x与delete 0 的区别只在于result是一个引用 delete 其实只能删除一种引用,即对象的成员 delete x中,如果x根本不存在,会发生什么? 返回true delete object.x中,如果x是只读的,会发生什么? 返回false,若是严格模式会报错 02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质 这行代码会泄漏一个全局变量y var 等声明语句总是在变量作用域或词法作用域中静态地声明一个或多个标识符. 全局变量的管理范式决定了“向一个不存在的变量赋值”所导致的变量泄漏是不可避免的 动态添加的“var声明”是可以删除的,这是唯一能操作varNames列表的方式 变量声明在引擎的处理上被分成了两部分,一部分是静态的,基于标识符的词法分析和管理,他总是在相应上下文的环境构建时作为名字创建的,另一部分是表达式执行过程,对上述名字的赋值,这个过程也称为绑定 不能删除var声明的变量,但是可以删除不实用var声明的全局变量 03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题 var a = {n:1} a.x = a = {n:2} console.log(a.x)//undefined console.log(a) // { n: 2 } 这是因为首先在访问a.x的时候,将{n:1}赋值给了a.x,然后又重新给a赋了新值,所以导致之前赋值的a.x丢失 js权威指南中声明:js总是严格按照从左到右的顺序来计算表达式 with只指定属性查找的优先级,所以with里面的x=100还是会泄漏到全局 04 | export default function() {}：你无法导出一个匿名函数表达式 es6的模块是静态配置的 传统的node.js模块却是动态加载的 //导出值 export default //导出声明的名字 export x //导出其他模块的名字 export ... from ... 一个export可以理解为如下两个步骤: 导出一个名字 为上述名字绑定一个值 export default function() {}并不是导出一个匿名函数表达式,而是导出一个匿名函数定义 05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销 switch的性能要高于if,是因为switch语句只有一个作用域,无法访问到外部声明的变量 var a = '111',c = 1; switch (c) { case 1: console.log(a); break; case 2: let a='22'; break;Ï default: break; } 所有在语句内可以存在的东西只有四种:表达式,其他语句,标识符声明和一种特殊的语法元素 变量作用域:var和函数声明 词法作用域:其他情况下的标识符和变量声明 单语句不支持词法声明 for (let i =0;i这是因为单语句没有块级作用域,而词法声明是不可覆盖的,单语句后面的词法声明会存在潜在的冲突 因为在es6中,只要使用了大括号,就代表着块级作用域,所以不管是用let还是var,一定是会创建相应的循环数量的块级作用域的 如果不使用大括号,在for中使用let,也会创建相应循环数量的块级作用域. 也就是说,可以提高性能的唯一情况只有,循环体是单行语句就不使用大括号且for中使用var 06 | x/ break x; 搞懂如何在循环外使用break，方知语句执行真解 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-20 09:14:27 "},"图解GoogleV8/":{"url":"图解GoogleV8/","title":"图解GoogleV8","keywords":"","body":"图解GoogleV8 [ ] 闭包 [ ] 作用域链 [ ] 原型链 [ ] 两个链之间的区别 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 11:28:36 "},"图解GoogleV8/00.html":{"url":"图解GoogleV8/00.html","title":"开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？","keywords":"","body":"开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？ 什么是v8? V8是js虚拟机的一种,我们可以简单的把js虚拟机理解成一个翻译程序,将人类能够理解的编程语言js,翻译成能够理解的机器语言. V8是早于其他虚拟机引入了惰性编译,内联缓存,隐藏类等机制,进一步优化了js代码的编译执行效率 V8的主要功能就是结合js语言的特性和本质来编译执行它,通过深入地学习V8,你对js语言本质和设计思想会有很直观的感受. 如何学习V8? js 借鉴了很多语言特性:比如C语言的基本语法,java的类型系统和内存管理,scheme的函数作为一蹦公民,还有self基于原型的继承机制 V8是js的实现,在学习V8工作原理时,我们需要额外关注js这些独特的设计思想和特性背后的实现,比如,为了实现函数是一等公民的特性,js采取了鲫鱼对象的策略,再比如为了实现原型继承,V8为每个对象引入了proto属性 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 10:08:33 "},"图解GoogleV8/01.html":{"url":"图解GoogleV8/01.html","title":"01 | V8是如何执行一段JavaScript代码的？","keywords":"","body":"01 | V8是如何执行一段JavaScript代码的？ 什么是v8? v8是一个由google开发的js引擎,目前用在chrome浏览器和node.js中,其核心功能是执行易于人类理解的js代码 高级代码为什么需要先编译在执行? 主要核心流程分为编译和执行两步 首先需要将js代码转换成低级中间代码或者机器能够理解的机器代码 然后执行转换后的代码并输出执行结果 cpu只能识别机器指令,但是对于程序员来说,二进制代码难以阅读和记忆,于是我们将二进制指令集转换为人类可以识别和记忆的富符号,这就是汇编指令集. 汇编语言的不好之处 不同的cpu有着不同的指令集 在编写汇编代码的时候,我们需要了解和处理器架构相关的硬件知识.比如你需要使用寄存器,内存,操作cpu等.我们在编写应用的时候,只想专心处理业务逻辑,并不想要过多理会这些处理器架构相关的细节 因此我们需要一种屏蔽了计算机架构细节的语言,能适应多种不同cpu架构的语言,只专心处理业务逻辑的语言,比如c,c++,java,c#,Python,js等这些高级语言 执行高级语言的方法 解释执行:首先将输入的源代码通过解析器编译成中间代码,之后直接使用解释器解释执行中间代码,然后直接输出结果,具体流程如下 编译执行:采用这种方式,也需要先将源代码转换成中间代码,然后我们的编译器再将中间代码转换成机器代码.通常编译成的机器代码是以二进制文件形式存储的,需要执行这段程序的时候直接执行二进制文件就可以了,还可以使用虚拟机将编译后的机器代码保存在内存中,然后直接执行内存中的二进制代码 不同的浏览器对js这一门语言的实现也是不同的,例如safari使用的是jscore虚拟机,firefox使用了traceMonkey虚拟机,而chrome则使用了v8虚拟机 v8是怎么执行js代码的? 实际上v8并没有采用某种单一的技术,而是混合编译执行和解释执行这两种手段,我们把这种混合使用编译器和解释器的技术称为jit技术 这是一种权衡策略,因为这两种方式都有各自的优缺点, 解释器执行的启动速度快,但是执行时的速度慢 编译执行的启动速度慢,但是执行时的速度快 v8启动执行js之前,他需要准备执行js时所需要的一些基础环境,包括堆栈空间,全局作用域,消息循环系统,内置函数等. js全局执行上下文就包括了执行过程中的全局信息,比如一些内置函数,全局变量等信息 全局作用域包含了一些全局变量,在执行过程中的数据都需要存放在内存中 v8采用了经典的堆和栈的内存管理模式,所以v8还需要初始化内存中的堆和栈机构 还需要初始化消息循环系统,消息循环系统包含了消息驱动器和消息队列,它如同v8的心脏,不断接受消息并决策如何处理消息 相信你注意到了，我们在解释器附近画了个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器会在后 台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进 制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么V8会优先选择 优化之后的二进制代码，这样代码的执行速度就会大幅提升。 不过，和静态语言不同的是，JavaScript是一种非常灵活的动态语言，对象的结构和属性是可 以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在 执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时 候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解 释执行。 理解了这一点，我们就可以来深入分析V8执行一段JavaScript代码所经历的主要流程了，这 包括了: 解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译 执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺 点，V8采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执 行频率超过一个值，那么V8就会采用优化编译器将其编译成执行效率更加高效的机器代码。 因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段， 第一种是将高级代码转换为二进制代码，再让计算机去执行; 另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。 V8是由Google开发的开源JavaScript引擎，也被称为虚拟机，模拟实际计算机各种功能来实 现代码的编译和执行。那么，要想搞清楚V8内部的工作流程和原理，我们可以从分析计算机 对语言的编译和执行过程入手。 初始化基础环境 解析源码生成AST和作用域 依据AST和作用域生成字节码 解释执行字节码 监听热点代码 优化热点代码为二进制的机器代码 反优化热点代码为二进制的机器代码 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 20:53:57 "},"图解GoogleV8/02.html":{"url":"图解GoogleV8/02.html","title":"02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点","keywords":"","body":"02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点 什么是js中的对象?它和面向对象语言中的“对象”有什么区别? js是一门基于对象的语言,可以说,js中大部分的内容都是由对象构成的,诸如函数,数组,也可以说js是建立在对象之上的语言 这些对象在运行时可以动态修改其内容,这就造就了js的超级灵活特性. 虽然js是基于对象设计的,但是它却不是一门面向对象的语言,因为面向对象语言天生支持封装,继承,多态,但是js并没有直接提供多态的支持,因此要在js中使用多态并不是一件容易的事 js中实现继承的方式,只是在对象中添加一个称为原型的属性,把继承的对象通过原型链接起来,就实现了继承,我们把这种继承方式称为基于言行链继承 对象的属性值有三种类型: 原始类型:null,undefined,boolean,number,string,bigint,symbol 对象类型 函数类型 函数到底关联了哪些内容? 函数作为一个对喜庆,它有自己的属性和值,所以函数关联了基础的属性和值 函数之所以称为特殊的对象,这个特殊的地方是函数可以“被调用”,所以一个函数被调用事,它还需要关联相关的执行上下文 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 11:28:22 "},"图解GoogleV8/03.html":{"url":"图解GoogleV8/03.html","title":"03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？","keywords":"","body":"03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？ js中的对象是由一组组属性和值的集合,从js语言的角度来看,js对象像一个字典,字符串作为键名,任意对象可以作为键值,可以通过键名读取键值 然而在V8实现对象存储时,并没有完全采用字段的存储方式,这主要是出于性能的考量,因为字典是非线性的数据结构,查询效率会低于线性的数据结构,V8为了提升存储和查找效率,采用了一套复杂的存储策略 function Foo(property_num,element_num){ for(let i = 0;i 因为js中的对象是由一组组属性和值组成的,所以最简单的方式是使用一个字典来保存属性和值,但是由于字典是非线性结构,所以使用如果使用字典,读取效率会大大降低 为了提升查找效率,V8在对象中添加了两个隐藏属性,排序属性和常规属性,指向了elements对象,在elements对象中,会按照顺序存放排序属性.properties属性则指向了properties对象,在properties对象中,会按照创建时的顺序保存常规属性 通过引入这两个属性,加速了V8查找属性的速度,为了更快进一步提升查找效率,V8还实现了内置内属性的策略,当常规属性少于一定数量时,V8就会将这些常规属性直接写进对象中,这样又节省了一个中间步骤 但是如果对象中的属性过多时,或者存在反复田间或者删除属性的操作,那么V8就会将线性的存储模式降级为非线性的字典存储模式,这样虽然降低了查找速度,但是却提升了修改对象的属性的速度. Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 14:43:25 "},"图解GoogleV8/04.html":{"url":"图解GoogleV8/04.html","title":"04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？","keywords":"","body":"04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？ 函数声明和函数表达式的区别 函数表达式是在表达式语句中使用 function 的,最典型的表达式是 a=b 这种形式,因为函数也是一个对象,我们把“a=function(){}”这种方式称为函数表达式 在函数表达式中,可以省略函数名称,从而创建匿名函数 一个函数表达式可以被用作一个即时调用的函数表达式--IIFE // 函数声明 function a() { // ... } // 函数表达式 const b = function () { // ... }; 执行过程 表达式就是表示值的式子,而语句是操作值的式子 在变量提升阶段,V8 并不会执行赋值的表达式,该阶段只会分析基础的语句,比如变量的定义,函数的声明 var x = 5; // 会执行两步操作: var x = undefined; //编译阶段完成的,也就是变量提升阶段完成的 x = 5; // 表达式,所有的表达式都是在执行阶段完成 在变量提升阶段,V8 将这些变量存放在作用域中,还会给他们赋一个默认的 undefined 值,所以在定义一个普通的变量之前,使用该变量,那么该变量的值就是 undefined 现在我们知道,表达式是不会在编译阶段执行的,那么函数声明是表达式还是语句呢? function foo(){ console.log('foo); } 执行上面这段代码,他并没有输出任何内容,所以可以肯定,函数声明并不是一个表达式, 而是一个语句.V8 在变量提升阶段,如果遇到函数声明,那么 V8 同样会对该函数声明执行变量提升操作 函数也是一个对象,所以在编译阶段,V8 就会将整个函数对象提升到作用域中,并不是给该函数名称赋一个 undefined. V8 是怎么处理函数表达式的? 在一个表达式中使用 function 来定义一个函数,那么就把该函数称为函数表达式. 函数立即表达式也是一个表达式,所以 V8 在编译阶段,并不会为该表达式创建函数对象,这样的一个好处就是不会污染全局环境,函数和函数内部的变量都不会被其他部分的代码访问到. V8 对于提升函数和提升变量的策略是不同的，如果提升了一个变量，那么 V8 在将变量提 升到作用域中时，还会为其设置默认值 undeifned，如果是函数声明，那么 V8 会在内存中创建 该函数对象，并提升整个函数对象 函数表达式也是表达式的一种，在编译阶段，V8 并不会将表达式中的函数对象提升到全局作 用域中，所以无法在函数表达式之前使用该函数。函数立即表达式是一种特别的表达式，主 要用来封装一些变量、函数，可以起到变量隔离和代码隐藏的作用，因此在一些大的开源项 目中有广泛的应用 var n = 1; (function () { n=100, console.log(n)//100 }()) console.log(n)//100 var n = 1 function foo() { n = 100; console.log(n)//100 } console.log(n)//1 foo() Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-20 12:56:03 "},"图解GoogleV8/05.html":{"url":"图解GoogleV8/05.html","title":"05｜原型链：V8是如何实现对象继承的？","keywords":"","body":"05｜原型链：V8是如何实现对象继承的？ 继承就是一个对象可以访问另外一个对象中的属性和方法,在js中,我们通过原型和原型链的方式来实现了继承特性 继承的两种方式: 基于类的实现 基于原型的实现 js仅仅在对象中引入了一个原型的属性,就实现了语言的继承机制,基于原型的继承省去了很多基于类继承的繁文缛节,简洁而优美 原型继承是如何实现的? js中的每个对象都包涵一个隐藏属性proto,我们就把该隐藏属性proto称为该对象的原型,proto指向了内存中的另一个对象,我们就把proto指向的对象称为该对象的原型对象,那么该对象就可以直接访问其原型对象的方法或者属性 原型链 查找属性的路径称为原型链,它像一个链条一样,将几个原型链接了起来 var animal = { type:'default', color:'default', getInfo:function () { return `type is ${this.type},color is ${this.color}`; } } var dog = { type:'dog', color:'black' } dog.__proto__= animal; var a = dog.getInfo(); console.log(a)//type is dog,color is black 通常情况下,隐藏属性是不能使用js来直接与之交互的. 虽然现代浏览器都开了一个口子,让js可以访问隐藏属性proto,但是在实际项目中,我们不应该直接通过proto来访问或者修改该属性,其主要原因有两个: 首先,这是隐藏属性,并不是标准定义的 其次,使用该属性会造成严重的性能问题 所以，在JavaScript中，是使用new加上构造函数的这种组合来创建对象和实现对象的继承 [info] 原型链是沿着对象的原型一级一级来查找属性的 作用域链 [info] 作用域链是沿着函数的作用域一级一级来查找变量的 构造函数是怎么创建对象的? function DogFactory(type,color) { this.type = type; this.color = color; } var dog = new DogFactory('dog', 'red'); 其实当V8执行上面这段代码时，V8会在背后悄悄地做了以下几件事情，模拟代码如下所示 var dog = {}; dog.__proto__=DogFactory.prototype DogFactory.call(dog,'dog','red') 为了加深你的理解，我画了上面这段代码的执行流程图 由上图可知,执行流程分为三步: 首先创建一个空白对象 然后将DogFactory的prototype属性设置为dog的原型对象,这就是给dog对象设置原型对象的关键一步, 最后,在使用dog来调用DogFactory,这时候DogFactory函数中的this就指向了对象dog,然后在DogFactory函数中,利用this对对象dog执行属性填充属性,最终就创建了dog对象 构造函数怎么实现继承? 函数除了拥有name和code这两个隐藏属性之外,还有另一个prototype属性 每个函数对象中都有一个公开的prototype属性，当你将这个函数作为构造函数来创建一个新 的对象时，新创建对象的原型对象就指向了该函数的prototype属性。当然了，如果你只是正常调用该函数，那么prototype属性将不起作用 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 18:04:25 "},"图解GoogleV8/06.html":{"url":"图解GoogleV8/06.html","title":"06｜作用域链：V8是如何查找变量的？","keywords":"","body":"06｜作用域链：V8是如何查找变量的？ 作用域 全局作用域在V8启动过程中就创建了,且一直保存在内存中不会被销毁的,直至V8退出, 包含全局的this值,如果是浏览器,还有window,document,opener等非常多的方法和对象,如果是node环境,会有global,file等内容 函数作用域是在执行该函数时创建的,当函数执行结束之后,函数作用域就随之被销毁掉了 函数的作用域是在执行阶段确定的,不是在定义阶段 词法作用域是根据函数在代码中的位置来确定的,作用域是在声明函数时就确定好的了,所以我们也将作用域称为静态作用域 和静态作用域相对的是动态作用域,动态作用域并不关心函数和作用域是如何身影以及在何处声明的,只关心他们从何处调用,换句话说,作用域是基于调用栈的,而不是基于函数定义的位置的. js所采用的作用域机制就是词法作用域,所以作用域链的路径就是按照词法作用域来实现的 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-13 10:24:56 "},"图解GoogleV8/07.html":{"url":"图解GoogleV8/07.html","title":"07｜类型转换：V8是怎么实现1+“2”的？","keywords":"","body":"07｜类型转换：V8是怎么实现1+“2”的？ 什么是类型系统?(类型的概念,js操作类型的策略) 每种语言都定义了自己的类型,还定义了如何操作这些类型,另外还定义了这些类型应该如何相互作用,我们就把这称为类型系统 对于机器语言来说,所有的数据都是一堆二进制代码,cpu处理这些数据的时候,并没有类型的概念,cpu所做的仅仅是移动数据,比如对其进行移位,相加或相乘 在高级语言中,我们都会为操作的数据赋予指定的类型,类型可以确认一个值或者一组值,具有特定的意义和目的.所以,类型是高级语言中的概念 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-13 11:26:00 "},"图解GoogleV8/08.html":{"url":"图解GoogleV8/08.html","title":"08｜答疑：如何构建和使用V8的调试工具d8？","keywords":"","body":"08｜答疑：如何构建和使用V8的调试工具d8？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/09.html":{"url":"图解GoogleV8/09.html","title":"09 | 运行时环境：运行JavaScript代码的基石","keywords":"","body":"09 | 运行时环境：运行JavaScript代码的基石 js是一门基于对象的语言,它能实现诸如函数是一等公民,闭包,函数式编程,原型继承等 当想要执行一段js代码时,只需要将代码丢给V8虚拟机,V8便会执行并返回给你结果 这是因为在执行js代码之前,v8就已经准备好了代码的运行时环境,这个环境包括了堆空间和栈空间,全局执行上下文,全局作用域,内置的内建函数,宿主环境提供的扩展函数和对象,还有消息循环系统. 准备好运行时环境之后,V8才可以执行js代码,这包括解析源码,生成字节码,解释执行或者编译执行这一系列操作 运行时环境 什么是宿主环境? 宿主环境在这里就是浏览器,主要为V8提供基础的消息循环系统,全局变量,Web API,而V8的核心是实现了es标准,v8只提供了es定义的一些对象和一些核心的函数,这包括object,function,string,除此之外,v8还提供了垃圾回收器,协程等基础内容. 构建数据存储空间:堆空间和栈空间 栈空间主要是用来管理js函数调用的,栈是内存中连续的一块空间,同时栈结构是“先进先出”的策略,在函数调用过程中.涉及到上下文相关的内容都会存放在栈上.比如原生类型,引用到的对象的地址,函数的执行状态,this值等斗鸡存在栈上,当一个函数执行结束,那么该函数的执行上下文便会被销毁掉. 栈空间的最大的特点是空间连续,所以在栈中每个元素的地址都是固定的,因此栈空间的查找效率非常高 堆空间是一种树形的存储结构,用来存储对象类型的离散的数据. 全局执行上下文和全局作用域 V8用执行上下文来维护执行当前代码所需要的变量声明,this指向等 执行上下文主要包含三部分:变量环境,词法环境和this关键字. 在浏览器环境中:全局执行上下文中包括了window对象,默认指向window的this关键字,还有一些web api,比如settimeout,XMLHttprequest等内容 构造时间循环系统 v8有一个主线程,用来执行js和执行垃圾回收等工作,v8是寄生在宿主环境中的,他并没有自己的主线程,而是适应宿主所提供的主线程,V8所执行的代码都是在宿主的主线程上执行的 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 18:12:34 "},"图解GoogleV8/10.html":{"url":"图解GoogleV8/10.html","title":"10 | 机器代码：二进制机器码究竟是如何被CPU执行的？","keywords":"","body":"10 | 机器代码：二进制机器码究竟是如何被CPU执行的？ 内存中的每个存储空间都有其对应的独一无二的地址. 通用寄存器和内存的关系:通用寄存器容量小,读写速度快,内存容量大,读写速度慢 通用寄存器通常用来存放数据或者内存中某块数据的地址,我们把这个地址称为指针,通常情况下寄存器对存放的数据是没有特别的限制的,比如某个通用寄存器既可以存储数据,也可以存储指针. 不过由于历史原因,我们还会将某些专用的数据或者指针存储在专用的通用寄存器中,比如rbp寄存器通常是用来存放栈指针的,rsp寄存器用来存放栈顶指针的,pc寄存器用来存放下一条哟执行的指令等. 由于cpu只能执行机器代码,所以我们需要将c代码转换成机器代码,这个转换过程就是由c编译器完成的 cpu执行机器代码的逻辑非常简单,首先编译之后的二进制代码被加载进内存,然后cpu就按照指令的顺序,一行一行的执行. 在执行指令的国过程中,cpu需要对数据执行读写操作,如果直接读写内存,那么会造成严重影响程序的执行性能,因此cpu就引入了寄存器,将一些中间数据存放在寄存器中,这样就能加速cpu的执行速度 有了寄存器之后,cpu执行指令的操作就变得简单了一点,因为需要寄存器和内存之间传输数据,或者寄存器和寄存器之间传输数据,我们通常有以下几种方式使用寄存器,包括了加载指令,存储指令,更新指令. Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 18:13:29 "},"图解GoogleV8/11.html":{"url":"图解GoogleV8/11.html","title":"11 | 堆和栈：函数调用是如何影响到内存布局的？","keywords":"","body":"11 | 堆和栈：函数调用是如何影响到内存布局的？ // 在同一个任务中重复调用嵌套的foo函数 function foo() { foo()//堆栈溢出 } foo() // 使用setTimeout函数在不同的任务中执行 function foo() { setTimeout(foo, 0) } foo() // 在同一个任务中执行foo函数,但是却不是嵌套执行 function foo() { return Promise.resolve().then(foo) } foo() 为什么使用栈结构来管理函数调用? 函数可以被调用; 具有作用域机制,所谓的作用域机制,是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离,在函数内部定义的变量我们称为临时变量,临时变量只能在函数中被访问,外部函数通常无权访问,当函数执行结束之后,存放在内存中的临时变量也随之被销毁 栈如何管理函数调用? 函数在执行过程中,其内部的临时变量会按照执行顺序被压入到栈中. 一个函数的起始位置被称为栈桢指针 每个栈帧都对应着一个未运行完的函数,栈帧中保存了该函数的返回地址和局部变量 栈的优势 栈的结构非常适合函数调用过程 在栈上分配资源和销毁资源的速度非常快,这主要归结于栈空间是连续的,分配空间和销毁空间只需要移动下指针就可以了 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 18:15:36 "},"图解GoogleV8/12.html":{"url":"图解GoogleV8/12.html","title":"12 | 延迟解析：V8是如何实现闭包的？","keywords":"","body":"12 | 延迟解析：V8是如何实现闭包的？ 在编译js代码的时候,v8并不会一次性将所有的js解析为中间代码,这主要是基于以下两点: 如果一次编译所有的代码,会增加编译时间,这会严重影响到首次执行js代码的速度,让用户感觉到卡顿, 解析完成的字节码和编译之后的机器代码都会存在内存中,如果一次性解析和编译完成,那么中间代码和机器代码将会一直占用内存 因此,所有的js虚拟机都实现了惰性解析,所谓的惰性解析是指解析器在解析的过程中,如果遇到函数声明,那么会跳过函数内部的代码,并不会为其生成ast和字节码,而仅仅生成顶层代码的ast和字节码 闭包的三个特性 js允许在函数内部定义新的函数 可以在内部函数中访问父函数中定义的变量 函数可以作为另一个函数的返回值 v8还提供了另一个功能,就是函数的预解析. 在预解析的时候检查语法错误,检查函数内部是否引用了外部变量,如果引用了外部变量,预解析器会将栈中的变量复制到堆中,在下次执行到该函数的时候,直接使用堆中的引用,这样就解决了闭包带来的问题 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 18:18:05 "},"图解GoogleV8/13.html":{"url":"图解GoogleV8/13.html","title":"13 | 字节码（一）：V8为什么又重新引入字节码？","keywords":"","body":"13 | 字节码（一）：V8为什么又重新引入字节码？ 字节码的作用 解释器可以直接解释执行字节码 优化编译器可以将字节码编译成二进制代码,然后在执行二进制代码 字节码如何提升代码的启动速度 减少了编译的时间,这是因为生成机器代码比生成字节码需要花费更久的时间,但是直接执行机器代码却比没事执行字节码更高效 字节码如何降低代码的复杂度 因为字节码的执行过程和CPU执行二进制代码的过程类似,形似的执行流程,那么将字节码转换为不同架构的二进制代码的工作量也会大大降低,这就降低了转换底层代码的工作量 字节码的优势 解决启动问题:生成字节码的时间很短 解决空间问题:字节码占用内存不多,缓存字节码会大大降低内存的使用 代码架构清晰:采用字节码,可以简化程序的复杂度,使得v8移植到不同的cpu架构平台更加容易 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-15 15:33:42 "},"图解GoogleV8/14.html":{"url":"图解GoogleV8/14.html","title":"14｜字节码（二）：解释器是如何解释执行字节码的？","keywords":"","body":"14｜字节码（二）：解释器是如何解释执行字节码的？ 字节码的解释执行在编译流水线中的位置如下图 如何生成字节码? function add(x,y){ var z= x+y return z } console.log(add(1,2)) 解析过程如下 因为解释器就是模拟物理机器来执行字节码的,比如可以实现如取指令,解析指令,执行指令,存储数据等,所以解释器的执行架构和cpu处理机器代码的架构类似. 通常有两种类型的解释器 基于栈,基于栈的解释器使用栈来保存函数参数,中间运算结果,变量等 基于寄存器的虚拟机则支持寄存器的指令操作,使用寄存器来保存参数,中间计算结果 基于寄存器的解释器架构,具体可参考如下 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-15 16:12:46 "},"图解GoogleV8/15.html":{"url":"图解GoogleV8/15.html","title":"15 | 隐藏类：如何在内存中快速查找对象属性？","keywords":"","body":"15 | 隐藏类：如何在内存中快速查找对象属性？ V8对每个对象都做了如下两点假设 对象创建好了之后就不会添加新的属性 对象创建好了之后也不会删除属性 V8为每个对象都创建了一个隐藏类,对象的隐藏类中记录了该对象一些基础的布局信息,包括 对象中所包含的所有的属性 每种类型相对于对象偏移量 多个对象公用一个隐藏类 减少隐藏类的创建次数,也间接加速了代码的执行速度 减少了隐藏类的存储空间 什么情况下两个对象的形状是相同的,要满足以下两点: 相同的属性名称 相等的属性个数 最佳实践: 使用字面量初始化对象时,要保证属性数据的一致性 尽量使用字面量一次性初始化完成对象属性 尽量避免使用delete方法 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-25 18:24:22 "},"图解GoogleV8/16.html":{"url":"图解GoogleV8/16.html","title":"16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？","keywords":"","body":"16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？ 什么是内联缓存(IC) 内联缓存就是为每个函数添加了一个缓存,当第一次执行该函数时,v8会将函数中的存储,加载和调用相关的中间结果保存到反馈像向量中. 当再次执行时,v8就要去反馈向量中查找行管中间信息,如果命中了,那么就直接使用中间信息 一个反馈向量的一个插槽中可以包含多个隐藏类的信息 如果一个插槽中只包含1个隐藏类,那么我们称这种状态为单态 如果一个插槽中包含了2—4个隐藏类,那我们称这种状态为多态 如果一个插槽中超过4个隐藏类,那我们称这种状态为超类 函数的单一职责,也是同样的道理,如果函数的入参格式是固定的,那么就不会在反馈向量的隐藏类中存在多条信息,这样就避免了查找对比浪费的时间 function l(o) { return o.x } var o = {x:1,y:2} var o1 = {x:1,y:2,z:3} for (var i = 0;i 生成的隐藏类中包含如下信息: V8引入的ic,会监听每个函数的执行过程,并在一些关键的地方埋下监听点,这些包括了加载对象属性,给对象属性赋值,还有函数调用,v8会将监听到的数据写入一个称为反馈向量的结构中,同时v8会为每个执行的函数维护一个反馈向量,有了反馈向量混存的临时数据,v8就可以缩短对象属性的查找路径,从而提升执行效率 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-16 11:52:27 "},"图解GoogleV8/17.html":{"url":"图解GoogleV8/17.html","title":"17 | 消息队列：V8是怎么实现回调函数的？","keywords":"","body":"17 | 消息队列：V8是怎么实现回调函数的？ 什么是回调函数 回调函数其实也是一个函数,具有该函数的特性,他可以有参数和返回值,如果单独给出一个函数,你是看不出来它是不是回调函数的. 回调函数和普通函数的不同 主要在于它的调用方式,只有当某个函数被作为参数,传递给另外一个函数,或者传递给宿主环境,然后该函数放在函数内部或者宿主环境中被调用,我们称为回调函数 同步回调和异步回调的区别 同步回调函数是在执行函数内部被执行的,而异步回调函数是在执行函数外部被执行的 异步回调涉及消息队列和事件循环 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-16 14:04:05 "},"图解GoogleV8/18.html":{"url":"图解GoogleV8/18.html","title":"18 | 异步编程（一）：V8是如何实现微任务的？","keywords":"","body":"18 | 异步编程（一）：V8是如何实现微任务的？ 宏任务 指消息队列中等待被主线程执行的事件,由事件触发线程维护 调用栈是一种数据结构,用来管理在主线程上执行的函数的调用关系 微任务 指需要异步执行的函数,执行时机是在主函数执行结束之后,当前宏任务结束之前,由js引擎线程维护 微任务解决了宏任务执行世纪不可控的问题. 引入微任务主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗, 微任务技术栈:(消息队列,主线程,调用栈) 每个宏任务都会维护一个微任务队列 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-21 11:13:23 "},"常用工具/":{"url":"常用工具/","title":"常用工具","keywords":"","body":"常用工具 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"常用工具/00.html":{"url":"常用工具/00.html","title":"core-js 及垫片理念","keywords":"","body":"core-js 及垫片理念 core-js 是一个 JavaScript 标准库，它包含了 ECMAScript 2020 在内的多项特性的 polyfills，以及 ECMAScript 在 proposals 阶段的特性、WHATWG/W3C 新特性等 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:46:23 "},"常用工具/01.html":{"url":"常用工具/01.html","title":"Git 操作","keywords":"","body":"Git 操作 查看仓库的配置 git config --list --global(当前用户的所有仓库) git config --list --local(具体的某一个仓库) git config --list --system(对系统所有的登录的有效) 配置全局的 git 仓库 git config --global user.name \"Denise\" git config --global user.email 'deng.yanwen@icloud.com' 清除 git 配置 git config --unset --local user.name 建立 git 仓库 把已有的项目代码纳入 git 管理:git init 从远程新建项目, 然后 clone 下拉:git clone 修改之前的已提交的文件的名称 git mv readme readme.md 删除暂存区和本地工作目录的更改 git reset --hard 查看项目历史版本 git log --oneline(简洁的历史) git log -n2 --oneline git log --all (查看所有分支的提交历史) git 的核心对象:blob, tree, commit git cat-file -p , 查看 git 对象的内容 git cat-file -t , 查看 git 对象的类型 git cat-file -s , 查看 git 对象的大小 .git 文件中存放的内容 objects【文件夹】，存放所有的 git 对象，对象哈希值前两位是文件名，后 38 位作为对象文件名，可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看 HEAD 中存放指向当前分支所在的分支， config 当前 git 的配置文件 refs【文件夹】 heads 存放当前项目的所有分支 remotes 存放远程信息 tags 存放当前项目的所有分支 git branch -av 撤销操作 修改最后一次 commit 的信息：git commit --amend [danger] 注意: git log -p - 2: 查看最近两次提交历史的差异 git add -u: 将 git 已经跟踪的文件一起添加到暂存区 cp 原来的文件地址 需要拷贝到的地址: 拷贝文件 vi 文件名: 查看文件内容 mv 修改的文件的名称 改之后的文件名称 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 10:59:48 "},"常用工具/02.html":{"url":"常用工具/02.html","title":"本地仓库如何关联远程仓库","keywords":"","body":"本地仓库如何关联远程仓库 首先在远程仓库上建立一个空的项目 然后在本地新建一个项目，进入项目，执行命令git init,即为初始化本地的这个文件夹为一个git可以管理的仓库，这时候仓库会自动添加一个master分支 将本地仓库与远程仓库关联在一起，git remote add origin + 仓库地址 在新建本地代码之后，使用git push -u origin master将本地代码推送到远程仓库 [info] 注意:我们第一次push的时候,加上-u参数,Git就会把本地的master分支和远程的master分支进行关联起来,我们以后的push操作就不再需要加上-u参数了 之后就可以进行相关的代码操作了 [info] 注意：如果出现Git refusing to merge unrelated histories，解决方法为：git pull origin master后面跟上参数--allow-unrelated-histories Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 10:51:46 "},"日常总结/":{"url":"日常总结/","title":"日常总结","keywords":"","body":"日常总结 [ ] js分为那两种类型?都有什么特点,如何判断正确的类型? [ ] 你理解的原型是什么? [ ] bind,apply,call各有什么区别 [ ] es6中有使用过什么 [ ] js是如何运行的? Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-21 19:37:01 "},"日常总结/00.html":{"url":"日常总结/00.html","title":"接口测试","keywords":"","body":"接口测试 接口测试是通过设计输入和预期输出来完成测试验证的 接口测试是一个技术知识和业务知识相结合的工作,可以更好地提升你自己的技术实力 接口测试也是功能测试，要说有和界面测试不同的地方，仅仅是和我们交互的，不再是开发工程师设计的界面，而是测试工具或者代码 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 11:17:48 "},"日常总结/01_伪类&&伪元素.html":{"url":"日常总结/01_伪类&&伪元素.html","title":"伪类&&伪元素","keywords":"","body":"伪类&&伪元素 CSS3中的伪元素 伪元素用来将特殊的效果添加到某些选择器 ::after 已选中元素的最后一个子元素 ::before 已选中元素的第一个子元素 ::first-letter 选中某个款级元素的第一行的第一个字母 ::first-line 匹配某个块级元素的第一行 ::selection 匹配用户划词时的高亮部分 CSS3中的伪类 伪类用于向某些选择器添加特殊效果 :root 选择文档的根元素，等同于 html 元素 :empty 选择没有子元素的元素 :target 选取当前活动的目标元素 :not(selector) 选择除 selector 元素意外的元素 :enabled 选择可用的表单元素 :disabled 选择禁用的表单元素 :checked 选择被选中的表单元素 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n :nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数 :nth-child(odd) 、 :nth-child(even) 、 :nth-child(3n+1) :first-child 、 :last-child 、 :only-child :nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n :nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数 :nth-of-type(odd) 、 :nth-of-type(even) 、 :nth-of-type(3n+1) :first-of-type 、 :last-of-type 、 :only-of-type Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 17:48:14 "},"日常总结/02_css单位总结.html":{"url":"日常总结/02_css单位总结.html","title":"css单位总结","keywords":"","body":"css 单位总结 什么是响应式布局 响应式布局就是一个网站可以兼容多个终端，而不用为每个终端做一个指定的版本。。 什么是设备像素 设备像素也是物理像素，单位是 pt，pt 在 css 标准中属于绝对单位，显示屏是由一个个物理像素单位组成的， 设备像素和分辨率之间的关系 分辨率用的就是设备像素，例如375*667， 什么是 css 像素 css 像素的单位是 px，在css 规范中，css 有两种单位：绝对单位和相对单位，px 是一个相对单位，是相对于设备像素 设备像素比的作用是什么 window.devicePixelRatio获取像素比，作用是在不同的设备像素比的 每英寸像素点ppi 和 设备像素比dpr ppi：表示每英寸所包含的像素点数目，数目越高，显示的也就越清晰 dpr：设备像素比= 设备像素/css 像素 就是设置css 像素=物理像素 px/rem/vh/vw之间的关系 一般设计稿的大小尺寸是按照 iphone6的大小设置的，也就是750*1334， 这个时候我们在写的时候，css 的单位需要按照设计稿上的大小1/2，得到我们需要的。 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 17:48:58 "},"日常总结/03_面向对象继承精讲.html":{"url":"日常总结/03_面向对象继承精讲.html","title":"面向对象继承精讲","keywords":"","body":"面向对象继承精讲 1、typeof 可用其判断一个值是不是对象或是基本数据类型中的其中一种。 对一个值使用typeof操作符可能返回： undefined、string、number、boolean、symbol、object（对象或null）、function console.log(typeof 2); // number console.log(typeof true); // boolean console.log(typeof 'str'); // string console.log(typeof []); // object []数组的数据类型在 typeof 中被解释为object console.log(typeof function(){}); // function console.log(typeof {}); // object console.log(typeof undefined); // undefined console.log(typeof null); // object null 的数据类型被 typeof 解释为 object typeof 对于基本类型，除了null都可以显示正确的类型；对于对象，除了函数都会显示object。 对于null来说，虽然它是基本类型，但是会显示object，这是一个存在了很久的bug。 因为在js的最初版本中，使用的是32位系统，为了性能考虑使用低位存储了变量的类型信息，000开头代表是对象，然而null表示为全零，所以将它错误的判断为object。虽然现在的内部类型 判断代码已经改变了，但是对于这个bug却是一直流传下来。 2、instanceof 当左边是基本类型值时，一律返回false。 当左边是引用类型值时，如果右边的原型对象，在左边的原型链上存在，返回真，否则假。 instanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找得类型的prototype。 console.log(2 instanceof Number); // false console.log(true instanceof Boolean); // false console.log('str' instanceof String); // false console.log([] instanceof Array); // true console.log(function(){} instanceof Function); // true console.log({} instanceof Object); // true console.log([] instanceof Object); // true // console.log(undefined instanceof Undefined); // console.log(null instanceof Null); function Person(name, age) { this.name = name; this.age = age; } function Dog(name, age) { this.name = name; this.age = age; } var p = new Person('zs', 18); var d = new Dog('小花', 8); console.log(p instanceof Person); // true console.log(d instanceof Person); // true console.log(p instanceof Object); // false 3、constructor 用于获取根据构造函数创造的对象的类型 console.log((2).constructor.name); // Number console.log((true).constructor.name); // Boolean console.log(('str').constructor.name); // String console.log(([]).constructor.name); // Array console.log((function() {}).constructor.name); // Function console.log(({}).constructor.name); // Object 当创建一个对象，并更改它的原型时，该对象的类型将会改变。 function Person(name, age) { this.name = name; this.age = age; } var p = new Person('csm', 21); console.log(p.constructor.name); // Person // 改变原型 Person.prototype = { name: 'zs', age: 18 }; var p1 = new Person('csm', 21); console.log(p1.constructor.name); // Object 因此，当要修改对象的proptotype时，一定要设置constructor指向其构造函数 function Person(name, age) { this.name = name; this.age = age; } Person.prototype = { constructor: Person, name: 'zs', age: 18 }; var p = new Person('csm', 21); console.log(p.constructor.name); // Person 4、toString() 返回一个表示该对象的字符串 对于一个对象，toSting()返回\"[object type]\",其中type是对象类型。 如果不是对象，toString()返回应有的文本值。 console.log({}.toString()); // [object Object] console.log([1,2,3].toString()); // \"1,2,3\" toString()方法和String()方法的区别 toString()方法和String()方法都可以转换为字符串类型。 1、toString()可以将所有的数据都转换为字符串，除了null和undefined。 null和undefined调用toString()方法会报错。 如果当前数据为数字类型，则toString()括号中的可以写一个数字，代表进制，可以将数字转化为对应进制字符串。 2、String()可以将null和undefined转换为字符串，但是没法转进制字符串。 5、Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法结果精准的显示我们需要的数据类型。 console.log(Object.prototype.toString.call(2)); // [object Number] console.log(Object.prototype.toString.call(true)); // [object Boolean] console.log(Object.prototype.toString.call('str')); // [object String] console.log(Object.prototype.toString.call([])); // [object Array] console.log(Object.prototype.toString.call(function(){})); // [object Function] console.log(Object.prototype.toString.call({})); // [object Object] console.log(Object.prototype.toString.call(undefined)); // [object Undefined] console.log(Object.prototype.toString.call(null)); // [object Null] 就算我们改变对象的原型，依然会显示正确的数据类型。 PS：当你想获取创建该对象的构造函数时，不能使用该方法，该方法返回的是该对象顶端的指向。此时，可以使用constructor function Fn(){}; Fn.prototype = new Array(); var f = new Fn(); console.log(Object.prototype.toString.call(f)); // [object Object] 6、in 判断一个对象是否拥有这个属性。如果对象上没有，就去它的原型对象里面找 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.address = '杭州'; var p = new Person('csm', 21); console.log('name', p); // true 注意：这里name要加引号表示字符串，不然就是全局变量了 console.log('address', p); // true 7、hasOwnProperty 判断当前对象是否拥有这个属性，只到对象自身查找 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.address = '杭州'; var p = new Person('csm', 21); console.log('name', p); // true console.log('address', p); // false 8、isPrototypeOf 判断一个对象是否是某个实例的原型对象 function Dog(name, age) { this.name = name; this.age = age; } function Person(name, age) { this.name = name; this.age = age; } var p = new Person('csm', 21); // 判断p的原型指针是否指向传入构造函数的原型对象，这个过程会往上层层判断。 console.log(Person.prototype.isPrototypeOf(p)); // true console.log(Object.prototype.isPrototypeOf(p)); // true console.log(Dog.prototype.isPrototypeOf(p)); // false Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-15 15:04:13 "},"日常总结/04_[]==![].html":{"url":"日常总结/04_[]==![].html","title":"[]==![]","keywords":"","body":"04_[]==![] ==执行的判断操作 首先判断两者类型是否相同,相同的话就是比大小 类型不相同的话,那么就进行类型转换 会先判断是否对比null和undefined,是的话就单会true 判断两者类型是否为string和number,是的话就会将string转换成number 判断其中一方是否为boolean,是的话就会把boolean转为number,在进行判断 判断其中一方是否为object,且另一方为string,number或者symbol,是的话就会把object转为原始类型在进行判断 所以在执行[] == ![]的时候 ![] 是boolean值,且为false,也就是最终会转换成number 0 [] 是object类型,首先执行valueOf(),返回的是[],接着执行toString(),然后返回为‘’,‘’转换为number是0 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-21 12:55:31 "},"日常总结/05_面试小册子.html":{"url":"日常总结/05_面试小册子.html","title":"面试小册子","keywords":"","body":"ES6常考题 变量提升 函数提升优于变量提升,函数提升会把整个函数挪到作用域顶部,变量提升智慧吧声明挪到作用域顶部 var存在提升,我们能在声明之前使用,let,const因为暂时性死区的原因,不能在声明之前使用 var在全局作用域下声明变量会导致变量挂在在window上,其他两者不会 let和const作用基本一致,但是后者身影的变量不能再次赋值 模块化 优势 解决命名冲突 提高复用性 提高代码可维护性 方式 立即执行函数 AMD && CMD ES Module Commonjs exports是对module.exports的引用,不能使用exports直接导出一个对象es module和commonjs的区别 commonjs支持动态导入,也就是require(${path}/xx.js),esm不支持 commonjs是同步导入,因为用于服务端,文件都在本地,同步导入即使卡在主线程影响也不大,而esm是异步导入,因为用于浏览器,需要下载文件,如果也采用用不导入会对渲染有很大的影响 commonjs在导出时都是值拷贝,就算导出的值变了,导入的值也不会改变,所以如果想要更新值,必须重新导入一次,但是esm是实时绑定的方式,导入导出的值都执行同一个内存地址,所以导入值会随着导出值得变化而变化 Generator function *foo(x) { let y = 2 * (yield (x + 1)) // 6 y= 24 let z = yield (y / 3) // 8 z=13 return (x + y + z) // 42 } let it = foo(5) console.log(it.next()) // => {value: 6, done: false} console.log(it.next(12)) // => {value: 8, done: false} console.log(it.next(13)) // => {value: 42, done: true} Node中的event loop和浏览器中的有什么区别? node 的event loop分为六个阶段,每当进入某一个阶段的时候,都会从对应的回调队列中去除函数去执行.当队列为空或者执行的回调函数数量达到系统设定的阙值,就会进入下一阶段 new new发生了什么 新生成了一个对象 链接到原型 绑定this 返回新对象 实现一个new function create(){ let obj = {} let Con = [].shift.call(arguments) obj.__proto__ = Con.prototype let result = Con.apply(obj,arguments) return result instanceof Object ? result : obj } 创建一个空对象 获取构造函数 设置空对象的原型 绑定this,并执行构造函数 确保返回值为对象 什么是 XSS攻击,如何避免 就是想尽一切办法将可执行的代码注入到网页中 持久性工具 将可执行的代码添加到数据库,然后每次访问页面的时候,都会执行 非持久性攻击 通过从链接中取参数的形式, 防御 转码 开启白名单或者黑名单过滤 什么是CSRF, 跨站请求伪造, 优化小技巧 图片优化 压缩图片,减小图片大小 图片懒加载,等需要的时候在加载 dns预解析:添加link标签, rel=‘dns-prefeprefetch‘,href=“域名”,域名可去掉http,前缀 预解析:预加载其实是通过声明式的fetch,强制浏览器请求资源,并且不会阻塞onload,re=“preload” 预渲染:可以通过预渲染将下载的文件预先在后台渲染,通过rel=“prerender“ 懒执行: 懒加载:将不关键的内容延迟加载, 节流:间隔指定时间加载,调用接口 防抖:点击按钮,发送请求,但是不能每次点击按钮都发送请求,所以可以加上一个延时,点击之后多久没有点击,就发送请求 webpack性能优化 优化loader的搜索范围,添加include,exclude,给文件设置别名, 可以先通过dll打包框架代码,生成manℹifest.json,然后在构建业务代码的时候,直接引入就行,就不需要构建框架代码 可以减少webpack插件的使用,因为webpack插件,是在webpack构建的钩子函数中执行的 文件后缀列表,尽量短一点, 添加cache-loader,缓存没有更改的文件,使用HardSourceWebpackPlugin 开启parallel多线程打包等同于thread-loader Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 11:39:50 "},"日常总结/06_position.html":{"url":"日常总结/06_position.html","title":"position","keywords":"","body":"position position有哪几种属性？分别代表什么 static：默认值，无定位，正常出现在文档流中 relative:相对定位，相对于自己本身 absoulte：绝对定位，相对于第一个position不是static的上级元素进行定位 fixed：相对于浏览器窗口进行定位 sticky：是relative和fixed的组合，其表现为粘性布局 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 10:30:00 "},"日常总结/07_BFC.html":{"url":"日常总结/07_BFC.html","title":"BFC","keywords":"","body":"BFC BFC是什什么，怎么创建一个BFC BFC块级格式化上下文，是一个独立的渲染区域，规定不管内部的元素如何布局和外部毫无关系 满足下列任意一个条件： float的值不是none，设置为left，会将元素移动到左侧，并会被其他元素环绕 position的属性不是static或者relative display的值为inline-block，table-cell，flex， overflow不为visible，如何设置为hidden将会裁剪溢出的元素 BFC的特性: 使BFC内部浮动元素不会到处乱跑 和浮动元素产生边界 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 10:35:38 "},"日常总结/08_如何清除浮动.html":{"url":"日常总结/08_如何清除浮动.html","title":"如何清除浮动","keywords":"","body":"如何清除浮动 父元素设置高度 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 结尾处添加一个空标签，添加样式clear：both 父元素设置overflow：hidden等，将元素设置为BFC 父元素定义伪类添加样式 .clear:after{ display:block; clear:both; content:''; vidibility:hidden; height:0; } Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-22 13:06:40 "},"日常总结/09_css垂直水平居中.html":{"url":"日常总结/09_css垂直水平居中.html","title":"css垂直水平居中","keywords":"","body":"怎么实现元素的水平垂直居中 // 方法1 div { width: 200px; height: 200px; border: 1px solid red; position: relative; } p { width: 50px; height: 50px; background-color: aqua; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; } // 方法2 div { width: 200px; height: 200px; border: 1px solid red; position: relative; } p { width: 50px; height: 50px; background-color: aqua; position: absolute; top: calc(50% - 25px); left: calc(50% - 25px); } // 方法3 div { width: 200px; height: 200px; border: 1px solid red; display: flex; align-items: center; justify-content: center; } p { width: 50px; height: 50px; background-color: aqua; } // 行内元素 方法一 div { width: 200px; height: 200px; border: 1px solid red; text-align: center; line-height: 200px; } span { background-color: aqua; } // 行内元素 方法二 div { width: 200px; height: 200px; border: 1px solid red; display: table-cell; text-align: center; vertical-align: middle; } span { background-color: aqua; } Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-02-01 10:27:54 "},"日常总结/10_缓存.html":{"url":"日常总结/10_缓存.html","title":"缓存","keywords":"","body":"缓存 缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷 HTTP缓存 HTTP缓存:主要存在于服务器请求传输时需要记录的一些参数，在服务器代码上设置 ⚠️强缓存:cache-control 的 max-age 优先级高于 Expires ⚠️协商缓存:etag的优先级高于last-modify 浏览器缓存 浏览器缓存:主要是由前端JS代码主动存储的某些参数 缓存流程两点总结： 1、浏览器每次发起请求，都会在浏览器缓存里寻找该请求的标识和缓存内容。 2、浏览器每次收到返回结果，都会在浏览器缓存里保存该标识和缓存内容。 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-02-01 10:27:08 "}}