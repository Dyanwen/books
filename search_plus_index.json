{"./":{"url":"./","title":"介绍","keywords":"","body":"晨希-整理目录 JavaScript 核心原理解析 图解 Google V8 常用工具 日常总结 2022.01.11 [x] 开篇词 | 如何学习谷歌高性能 JavaScript 引擎 V8？ [x] 01 | V8 是如何执行一段 JavaScript 代码的？ 2022.01.12 [x] 02 | 函数即对象：一篇文章彻底搞懂 JavaScript 的函数特点 [x] 03 ｜快属性和慢属性：V8 采用了哪些策略提升了对象属性的访问速度？ [x] 04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？ [x] 05｜原型链：V8是如何实现对象继承的？ [x] 06｜作用域链：V8是如何查找变量的？ 2022.01.13 [x] 07｜类型转换：V8是怎么实现1+“2”的？ [x] 08｜答疑：如何构建和使用V8的调试工具d8？ [x] 09 | 运行时环境：运行JavaScript代码的基石 2022.01.14 [x] 10 | 机器代码：二进制机器码究竟是如何被CPU执行的？ [x] 11 | 堆和栈：函数调用是如何影响到内存布局的？ [x] 12 | 延迟解析：V8是如何实现闭包的？ [x] 13 | 字节码（一）：V8为什么又重新引入字节码？ [x] 14｜字节码（二）：解释器是如何解释执行字节码的？ 2022.01.15 [x] 15 | 隐藏类：如何在内存中快速查找对象属性？ [x] 16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？ [x] 17 | 消息队列：V8是怎么实现回调函数的？ [x] 18 | 异步编程（一）：V8是如何实现微任务的？ 2022.01.18 [ ] Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-18 20:08:58 "},"JavaScript核心原理解析/":{"url":"JavaScript核心原理解析/","title":"JavaScript核心原理解析","keywords":"","body":"JavaScript核心原理解析 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/00.html":{"url":"JavaScript核心原理解析/00.html","title":"开篇词 | 如何解决语言问题？","keywords":"","body":"开篇词 | 如何解决语言问题？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/01.html":{"url":"JavaScript核心原理解析/01.html","title":"01 | delete 0：JavaScript中到底有什么是可以销毁的","keywords":"","body":"01 | delete 0：JavaScript中到底有什么是可以销毁的 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/02.html":{"url":"JavaScript核心原理解析/02.html","title":"02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质","keywords":"","body":"02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/03.html":{"url":"JavaScript核心原理解析/03.html","title":"03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题","keywords":"","body":"03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/04.html":{"url":"JavaScript核心原理解析/04.html","title":"04 | export default function() {}：你无法导出一个匿名函数表达式","keywords":"","body":"04 | export default function() {}：你无法导出一个匿名函数表达式 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/05.html":{"url":"JavaScript核心原理解析/05.html","title":"05 | for (let x of [1, 2, 3]) ...：for循环并不比使用函数递归节省开销","keywords":"","body":"05 | for (let x of [1, 2, 3]) ...：for循环并不比使用函数递归节省开销 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/06.html":{"url":"JavaScript核心原理解析/06.html","title":"06 | x/ break x; 搞懂如何在循环外使用break，方知语句执行真解","keywords":"","body":"06 | x/ break x; 搞懂如何在循环外使用break，方知语句执行真解 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/07.html":{"url":"JavaScript核心原理解析/07.html","title":"07 | ${1} ：详解JavaScript中特殊的可执行结构","keywords":"","body":"07 | ${1} ：详解JavaScript中特殊的可执行结构 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/08.html":{"url":"JavaScript核心原理解析/08.html","title":"08 | x => x：函数式语言的核心抽象：函数与表达式的同一性","keywords":"","body":"08 | x => x：函数式语言的核心抽象：函数与表达式的同一性 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/09.html":{"url":"JavaScript核心原理解析/09.html","title":"09 | (...x)：不是表达式、语句、函数，但它却能执行","keywords":"","body":"09 | (...x)：不是表达式、语句、函数，但它却能执行 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/10.html":{"url":"JavaScript核心原理解析/10.html","title":"10 | x = yield x：迭代过程的“函数式化”","keywords":"","body":"10 | x = yield x：迭代过程的“函数式化” Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/11.html":{"url":"JavaScript核心原理解析/11.html","title":"11 | throw 1; ：它在“最简单语法榜”上排名第三","keywords":"","body":"11 | throw 1; ：它在“最简单语法榜”上排名第三 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/12.html":{"url":"JavaScript核心原理解析/12.html","title":"12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false","keywords":"","body":"12 | 1 in 1..constructor：这行代码的结果，既可能是true，也可能是false Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/13.html":{"url":"JavaScript核心原理解析/13.html","title":"13 | new X：从构造器到类，为你揭密对象构造的全程","keywords":"","body":"13 | new X：从构造器到类，为你揭密对象构造的全程 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/14.html":{"url":"JavaScript核心原理解析/14.html","title":"14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲","keywords":"","body":"14 | super.xxx()：虽然直到ES10还是个半吊子实现，却也值得一讲 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/15.html":{"url":"JavaScript核心原理解析/15.html","title":"15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类","keywords":"","body":"15 | return Object.create(new.target.prototype)：做框架设计的基本功：写一个根类 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/16.html":{"url":"JavaScript核心原理解析/16.html","title":"16 | [a, b] = {a, b}：让你从一行代码看到对象的本质","keywords":"","body":"16 | [a, b] = {a, b}：让你从一行代码看到对象的本质 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/17.html":{"url":"JavaScript核心原理解析/17.html","title":"17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着","keywords":"","body":"17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/18.html":{"url":"JavaScript核心原理解析/18.html","title":"18 | a + b：动态类型是灾难之源还是最好的特性？（上）","keywords":"","body":"18 | a + b：动态类型是灾难之源还是最好的特性？（上） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/19.html":{"url":"JavaScript核心原理解析/19.html","title":"19 | a + b：动态类型是灾难之源还是最好的特性？（下）","keywords":"","body":"19 | a + b：动态类型是灾难之源还是最好的特性？（下） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/20.html":{"url":"JavaScript核心原理解析/20.html","title":"20 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（上）","keywords":"","body":"20 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（上） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/21.html":{"url":"JavaScript核心原理解析/21.html","title":"21 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（下）","keywords":"","body":"21 | (0, eval)(\"x = 100\") ：一行让严格模式形同虚设的破坏性设计（下） Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/22.html":{"url":"JavaScript核心原理解析/22.html","title":"22 | new Function('x = 100')(); ：函数的类化是对动态与静态系统的再次统一","keywords":"","body":"22 | new Function('x = 100')(); ：函数的类化是对动态与静态系统的再次统一 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/23.html":{"url":"JavaScript核心原理解析/23.html","title":"加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？","keywords":"","body":"加餐 | 捡豆吃豆的学问（上）：这门课讲的是什么？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/24.html":{"url":"JavaScript核心原理解析/24.html","title":"加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？","keywords":"","body":"加餐 | 捡豆吃豆的学问（下）：这门课该怎么学？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/25.html":{"url":"JavaScript核心原理解析/25.html","title":"加餐 | 让JavaScript运行起来","keywords":"","body":"加餐 | 让JavaScript运行起来 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"JavaScript核心原理解析/26.html":{"url":"JavaScript核心原理解析/26.html","title":"结束语 | 愿你能做一个真正“懂”的程序员","keywords":"","body":"结束语 | 愿你能做一个真正“懂”的程序员 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/":{"url":"图解GoogleV8/","title":"图解GoogleV8","keywords":"","body":"图解GoogleV8 [ ] 闭包 [ ] 作用域链 [ ] 原型链 [ ] 两个链之间的区别 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 11:28:36 "},"图解GoogleV8/00.html":{"url":"图解GoogleV8/00.html","title":"开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？","keywords":"","body":"开篇词 | 如何学习谷歌高性能 JavaScript 引擎V8？ 什么是v8? V8是js虚拟机的一种,我们可以简单的把js虚拟机理解成一个翻译程序,将人类能够理解的编程语言js,翻译成能够理解的机器语言. V8是早于其他虚拟机引入了惰性编译,内联缓存,隐藏类等机制,进一步优化了js代码的编译执行效率 V8的主要功能就是结合js语言的特性和本质来编译执行它,通过深入地学习V8,你对js语言本质和设计思想会有很直观的感受. 如何学习V8? js 借鉴了很多语言特性:比如C语言的基本语法,java的类型系统和内存管理,scheme的函数作为一蹦公民,还有self基于原型的继承机制 V8是js的实现,在学习V8工作原理时,我们需要额外关注js这些独特的设计思想和特性背后的实现,比如,为了实现函数是一等公民的特性,js采取了鲫鱼对象的策略,再比如为了实现原型继承,V8为每个对象引入了proto属性 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 10:08:33 "},"图解GoogleV8/01.html":{"url":"图解GoogleV8/01.html","title":"01 | V8是如何执行一段JavaScript代码的？","keywords":"","body":"01 | V8是如何执行一段JavaScript代码的？ 什么是v8? v8是一个由google开发的js引擎,目前用在chrome浏览器和node.js中,其核心功能是执行易于人类理解的js代码 高级代码为什么需要先编译在执行? 主要核心流程分为编译和执行两步 首先需要将js代码转换成低级中间代码或者机器能够理解的机器代码 然后执行转换后的代码并输出执行结果 cpu只能识别机器指令,但是对于程序员来说,二进制代码难以阅读和记忆,于是我们将二进制指令集转换为人类可以识别和记忆的富符号,这就是汇编指令集. 汇编语言的不好之处 不同的cpu有着不同的指令集 在编写汇编代码的时候,我们需要了解和处理器架构相关的硬件知识.比如你需要使用寄存器,内存,操作cpu等.我们在编写应用的时候,只想专心处理业务逻辑,并不想要过多理会这些处理器架构相关的细节 因此我们需要一种屏蔽了计算机架构细节的语言,能适应多种不同cpu架构的语言,只专心处理业务逻辑的语言,比如c,c++,java,c#,Python,js等这些高级语言 执行高级语言的方法 解释执行:首先将输入的源代码通过解析器编译成中间代码,之后直接使用解释器解释执行中间代码,然后直接输出结果,具体流程如下 编译执行:采用这种方式,也需要先将源代码转换成中间代码,然后我们的编译器再将中间代码转换成机器代码.通常编译成的机器代码是以二进制文件形式存储的,需要执行这段程序的时候直接执行二进制文件就可以了,还可以使用虚拟机将编译后的机器代码保存在内存中,然后直接执行内存中的二进制代码 不同的浏览器对js这一门语言的实现也是不同的,例如safari使用的是jscore虚拟机,firefox使用了traceMonkey虚拟机,而chrome则使用了v8虚拟机 v8是怎么执行js代码的? 实际上v8并没有采用某种单一的技术,而是混合编译执行和解释执行这两种手段,我们把这种混合使用编译器和解释器的技术称为jit技术 这是一种权衡策略,因为这两种方式都有各自的优缺点, 解释器执行的启动速度快,但是执行时的速度慢 编译执行的启动速度慢,但是执行时的速度快 v8启动执行js之前,他需要准备执行js时所需要的一些基础环境,包括堆栈空间,全局作用域,消息循环系统,内置函数等. js全局执行上下文就包括了执行过程中的全局信息,比如一些内置函数,全局变量等信息 全局作用域包含了一些全局变量,在执行过程中的数据都需要存放在内存中 v8采用了经典的堆和栈的内存管理模式,所以v8还需要初始化内存中的堆和栈机构 还需要初始化消息循环系统,消息循环系统包含了消息驱动器和消息队列,它如同v8的心脏,不断接受消息并决策如何处理消息 相信你注意到了，我们在解释器附近画了个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器会在后 台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进 制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么V8会优先选择 优化之后的二进制代码，这样代码的执行速度就会大幅提升。 不过，和静态语言不同的是，JavaScript是一种非常灵活的动态语言，对象的结构和属性是可 以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在 执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时 候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解 释执行。 理解了这一点，我们就可以来深入分析V8执行一段JavaScript代码所经历的主要流程了，这 包括了: 解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译 执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺 点，V8采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执 行频率超过一个值，那么V8就会采用优化编译器将其编译成执行效率更加高效的机器代码。 因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段， 第一种是将高级代码转换为二进制代码，再让计算机去执行; 另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。 V8是由Google开发的开源JavaScript引擎，也被称为虚拟机，模拟实际计算机各种功能来实 现代码的编译和执行。那么，要想搞清楚V8内部的工作流程和原理，我们可以从分析计算机 对语言的编译和执行过程入手。 初始化基础环境 解析源码生成AST和作用域 依据AST和作用域生成字节码 解释执行字节码 监听热点代码 优化热点代码为二进制的机器代码 反优化热点代码为二进制的机器代码 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 20:53:57 "},"图解GoogleV8/02.html":{"url":"图解GoogleV8/02.html","title":"02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点","keywords":"","body":"02 | 函数即对象：一篇文章彻底搞懂JavaScript的函数特点 什么是js中的对象?它和面向对象语言中的“对象”有什么区别? js是一门基于对象的语言,可以说,js中大部分的内容都是由对象构成的,诸如函数,数组,也可以说js是建立在对象之上的语言 这些对象在运行时可以动态修改其内容,这就造就了js的超级灵活特性. 虽然js是基于对象设计的,但是它却不是一门面向对象的语言,因为面向对象语言天生支持封装,继承,多态,但是js并没有直接提供多态的支持,因此要在js中使用多态并不是一件容易的事 js中实现继承的方式,只是在对象中添加一个称为原型的属性,把继承的对象通过原型链接起来,就实现了继承,我们把这种继承方式称为基于言行链继承 对象的属性值有三种类型: 原始类型:null,undefined,boolean,number,string,bigint,symbol 对象类型 函数类型 函数到底关联了哪些内容? 函数作为一个对喜庆,它有自己的属性和值,所以函数关联了基础的属性和值 函数之所以称为特殊的对象,这个特殊的地方是函数可以“被调用”,所以一个函数被调用事,它还需要关联相关的执行上下文 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 11:28:22 "},"图解GoogleV8/03.html":{"url":"图解GoogleV8/03.html","title":"03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？","keywords":"","body":"03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？ js中的对象是由一组组属性和值的集合,从js语言的角度来看,js对象像一个字典,字符串作为键名,任意对象可以作为键值,可以通过键名读取键值 然而在V8实现对象存储时,并没有完全采用字段的存储方式,这主要是出于性能的考量,因为字典是非线性的数据结构,查询效率会低于线性的数据结构,V8为了提升存储和查找效率,采用了一套复杂的存储策略 function Foo(property_num,element_num){ for(let i = 0;i 因为js中的对象是由一组组属性和值组成的,所以最简单的方式是使用一个字典来保存属性和值,但是由于字典是非线性结构,所以使用如果使用字典,读取效率会大大降低 为了提升查找效率,V8在对象中添加了两个隐藏属性,排序属性和常规属性,指向了elements对象,在elements对象中,会按照顺序存放排序属性.properties属性则指向了properties对象,在properties对象中,会按照创建时的顺序保存常规属性 通过引入这两个属性,加速了V8查找属性的速度,为了更快进一步提升查找效率,V8还实现了内置内属性的策略,当常规属性少于一定数量时,V8就会将这些常规属性直接写进对象中,这样又节省了一个中间步骤 但是如果对象中的属性过多时,或者存在反复田间或者删除属性的操作,那么V8就会将线性的存储模式降级为非线性的字典存储模式,这样虽然降低了查找速度,但是却提升了修改对象的属性的速度. Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 14:43:25 "},"图解GoogleV8/04.html":{"url":"图解GoogleV8/04.html","title":"04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？","keywords":"","body":"04 | 函数表达式：涉及大量概念，函数表达式到底该怎么学？ 函数声明和函数表达式的区别 函数表达式是在表达式语句中使用 function 的,最典型的表达式是 a=b 这种形式,因为函数也是一个对象,我们把“a=function(){}”这种方式称为函数表达式 在函数表达式中,可以省略函数名称,从而创建匿名函数 一个函数表达式可以被用作一个即时调用的函数表达式--IIFE // 函数声明 function a() { // ... } // 函数表达式 const b = function () { // ... }; 执行过程 表达式就是表示值的式子,而语句是操作值的式子 在变量提升阶段,V8 并不会执行赋值的表达式,该阶段只会分析基础的语句,比如变量的定义,函数的声明 var x = 5; // 会执行两步操作: var x = undefined; //编译阶段完成的,也就是变量提升阶段完成的 x = 5; // 表达式,所有的表达式都是在执行阶段完成 在变量提升阶段,V8 将这些变量存放在作用域中,还会给他们赋一个默认的 undefined 值,所以在定义一个普通的变量之前,使用该变量,那么该变量的值就是 undefined 现在我们知道,表达式是不会在编译阶段执行的,那么函数声明是表达式还是语句呢? function foo(){ console.log('foo); } 执行上面这段代码,他并没有输出任何内容,所以可以肯定,函数声明并不是一个表达式, 而是一个语句.V8 在变量提升阶段,如果遇到函数声明,那么 V8 同样会对该函数声明执行变量提升操作 函数也是一个对象,所以在编译阶段,V8 就会将整个函数对象提升到作用域中,并不是给该函数名称赋一个 undefined. V8 是怎么处理函数表达式的? 在一个表达式中使用 function 来定义一个函数,那么就把该函数称为函数表达式. 函数立即表达式也是一个表达式,所以 V8 在编译阶段,并不会为该表达式创建函数对象,这样的一个好处就是不会污染全局环境,函数和函数内部的变量都不会被其他部分的代码访问到. V8 对于提升函数和提升变量的策略是不同的，如果提升了一个变量，那么 V8 在将变量提 升到作用域中时，还会为其设置默认值 undeifned，如果是函数声明，那么 V8 会在内存中创建 该函数对象，并提升整个函数对象 函数表达式也是表达式的一种，在编译阶段，V8 并不会将表达式中的函数对象提升到全局作 用域中，所以无法在函数表达式之前使用该函数。函数立即表达式是一种特别的表达式，主 要用来封装一些变量、函数，可以起到变量隔离和代码隐藏的作用，因此在一些大的开源项 目中有广泛的应用 var n = 1; (function () { n=100, console.log(n)//100 }()) console.log(n)//100 var n = 1 function foo() { n = 100; console.log(n)//100 } console.log(n)//1 foo() Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 18:47:26 "},"图解GoogleV8/05.html":{"url":"图解GoogleV8/05.html","title":"05｜原型链：V8是如何实现对象继承的？","keywords":"","body":"05｜原型链：V8是如何实现对象继承的？ 继承就是一个对象可以访问另外一个对象中的属性和方法,在js中,我们通过原型和原型链的方式来实现了继承特性 继承的两种方式: 基于类的实现 基于原型的实现 js仅仅在对象中引入了一个原型的属性,就实现了语言的继承机制,基于原型的继承省去了很多基于类继承的繁文缛节,简洁而优美 原型继承是如何实现的? js中的每个对象都包涵一个隐藏属性proto,我们就把该隐藏属性proto称为该对象的原型,proto只想了内存中的另一个对象,我们就把proto指向的对象称为该对象的原型对象,那么该对象就可以直接访问其原型对象的方法或者属性 原型链 查找属性的路径称为原型链,它像一个链条一样,将几个原型链接了起来 var animal = { type:'default', color:'default', getInfo:function () { return `type is ${this.type},color is ${this.color}`; } } var dog = { type:'dog', color:'black' } dog.__proto__= animal; var a = dog.getInfo(); console.log(a)//type is dog,color is black 通常情况下,隐藏属性是不能使用js来直接与之交互的. 虽然现代浏览器都开了一个口子,让js可以访问隐藏属性proto,但是在实际项目中,我们不应该直接通过proto来访问或者修改该属性,其主要原因有两个: 首先,这是隐藏属性,并不是标准定义的 其次,使用该属性会造成严重的性能问题 所以，在JavaScript中，是使用new加上构造函数的这种组合来创建对象和实现对象的继承 [info] 原型链是沿着对象的原型一级一级来查找属性的 作用域链 [info] 作用域链是沿着函数的作用域一级一级来查找变量的 构造函数是怎么创建对象的? function DogFactory(type,color) { this.type = type; this.color = color; } var dog = new DogFactory('dog', 'red'); 其实当V8执行上面这段代码时，V8会在背后悄悄地做了以下几件事情，模拟代码如下所示 var dog = {}; dog.__proto__=DogFactory.prototype DogFactory.call(dog,'dog','red') 为了加深你的理解，我画了上面这段代码的执行流程图 由上图可知,执行流程分为三步: 首先创建一个空白对象 然后将DogFactory的prototype属性设置为dog的原型对象,这就是给dog对象设置原型对象的关键一步, 最后,在使用dog来调用DogFactory,这时候DogFactory函数中的this就指向了对象dog,然后在DogFactory函数中,利用this对对象dog执行属性填充属性,最终就创建了dog对象 构造函数怎么实现继承? 函数除了拥有name和code这两个隐藏属性之外,还有另一个prototype属性 每个函数对象中都有一个公开的prototype属性，当你将这个函数作为构造函数来创建一个新 的对象时，新创建对象的原型对象就指向了该函数的prototype属性。当然了，如果你只是正 常调用该函数，那么prototype属性将不起作用 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-12 20:05:00 "},"图解GoogleV8/06.html":{"url":"图解GoogleV8/06.html","title":"06｜作用域链：V8是如何查找变量的？","keywords":"","body":"06｜作用域链：V8是如何查找变量的？ 作用域 全局作用域在V8启动过程中就创建了,且一直保存在内存中不会被销毁的,直至V8退出, 包含全局的this值,如果是浏览器,还有window,document,opener等非常多的方法和对象,如果是node环境,会有global,file等内容 函数作用域是在执行该函数时创建的,当函数执行结束之后,函数作用域就随之被销毁掉了 函数的作用域是在执行阶段确定的,不是在定义阶段 词法作用域是根据函数在代码中的位置来确定的,作用域是在声明函数时就确定好的了,所以我们也将作用域称为静态作用域 和静态作用域相对的是动态作用域,动态作用域并不关心函数和作用域是如何身影以及在何处声明的,只关心他们从何处调用,换句话说,作用域是基于调用栈的,而不是基于函数定义的位置的. js所采用的作用域机制就是词法作用域,所以作用域链的路径就是按照词法作用域来实现的 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-13 10:24:56 "},"图解GoogleV8/07.html":{"url":"图解GoogleV8/07.html","title":"07｜类型转换：V8是怎么实现1+“2”的？","keywords":"","body":"07｜类型转换：V8是怎么实现1+“2”的？ 什么是类型系统?(类型的概念,js操作类型的策略) 每种语言都定义了自己的类型,还定义了如何操作这些类型,另外还定义了这些类型应该如何相互作用,我们就把这称为类型系统 对于机器语言来说,所有的数据都是一堆二进制代码,cpu处理这些数据的时候,并没有类型的概念,cpu所做的仅仅是移动数据,比如对其进行移位,相加或相乘 在高级语言中,我们都会为操作的数据赋予指定的类型,类型可以确认一个值或者一组值,具有特定的意义和目的.所以,类型是高级语言中的概念 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-13 11:26:00 "},"图解GoogleV8/08.html":{"url":"图解GoogleV8/08.html","title":"08｜答疑：如何构建和使用V8的调试工具d8？","keywords":"","body":"08｜答疑：如何构建和使用V8的调试工具d8？ Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"图解GoogleV8/09.html":{"url":"图解GoogleV8/09.html","title":"09 | 运行时环境：运行JavaScript代码的基石","keywords":"","body":"09 | 运行时环境：运行JavaScript代码的基石 js是一门基于对象的语言,它能实现诸如函数是一等公民,闭包,函数式编程,原型继承等 当想要执行一段js代码时,只需要将代码丢给V8虚拟机,V8便会执行并返回给你结果 这是因为在执行js代码之前,v8就已经准备好了代码的运行时环境,这个环境包括了堆空间和栈空间,全局执行上下文,全局作用域,内置的内建函数,宿主环境提供的扩展函数和对象,还有消息循环系统. 准备好运行时环境之后,V8才可以执行js代码,这包括解析源码,生成字节码,解释执行或者编译执行这一系列操作 运行时环境 什么是宿主环境? 宿主环境在这里就是浏览器,主要为V8提供基础的消息循环系统,全局变量,Web API,而V8的核心是实现了es标准,v8只提供了es定义的一些对象和一些核心的函数,这包括object,function,string,除此之外,v8还提供了垃圾回收器,协程等基础内容. 构建数据存储空间:堆空间和栈空间 栈空间主要是用来管理js函数调用的,栈是内存中连续的一块空间,同时栈结构是“先进先出”的策略,在函数调用过程中.涉及到上下文相关的内容都会存放在栈上.比如原生类型,引用到的对象的地址,函数的执行状态,this值等斗鸡存在栈上,当一个函数执行结束,那么该函数的执行上下文便会被销毁掉. 栈空间的最大的特点是空间连续,所以在栈中每个元素的地址都是固定的,因此栈空间的查找效率非常高 堆空间是一种树形的存储结构,用来存储对象类型的离散的数据. 全局执行上下文和全局作用域 V8用执行上下文来维护执行当前代码所需要的变量声明,this指向等 执行上下文主要包含三部分:变量环境,词法环境和this关键字. 在浏览器环境中:全局执行上下文中包括了window对象,默认指向window的this关键字,还有一些web api,比如settimeout,XMLHttprequest等内容 构造时间循环系统 v8有一个主线程,用来执行js和执行垃圾回收等工作,v8是寄生在宿主环境中的,他并没有自己的主线程,而是shying宿主所提供的主线程,V8所执行的代码都是在宿主的主线程上执行的 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-13 17:19:58 "},"图解GoogleV8/10.html":{"url":"图解GoogleV8/10.html","title":"10 | 机器代码：二进制机器码究竟是如何被CPU执行的？","keywords":"","body":"10 | 机器代码：二进制机器码究竟是如何被CPU执行的？ 内存中的每个存储空间都有其对应的独一无二的地址. 通用寄存器和内存的关系:通用寄存器容量小,读写速度快,内存容量大,读写速度慢 通用寄存器通常用来存放数据或者内存中某块数据的地址,我们把这个地址称为指针,通常情况下寄存器对存放的数据是没有特别的限制的,比如某个通用寄存器既可以存储数据,ykeyii存储指针. 不过由于历史原因,我们还会将某些专用的数据或者指针存储在专用的通用寄存器中,比如rbp寄存器通常是用来存放栈指针的,rsp寄存器用来存放栈顶指针的,pc寄存器用来存放下一条哟执行的指令等. 由于cpu只能执行机器代码,所以我们需要将c代码转换成机器代码,这个转换过程就是由c编译器完成的 cpu执行机器代码的逻辑非常简单,首先编译之后的二进制代码被加载进内存,然后cpu就按照指令的顺序,一行一行的执行. 在执行指令的国过程中,cpu需要对数据执行读写操作,如果直接读写内存,那么会造成严重影响程序的执行性能,因此cpu就引入了寄存器,将一些中间数据存放在寄存器中,这样就能加速cpu的执行速度 有了寄存器之后,cpu执行指令的操作就变得简单了一点,因为需要寄存器和内存之间传输数据,或者寄存器和寄存器之间传输数据,我们通常有以下几种方式使用寄存器,包括了加载指令,存储指令,更新指令. Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-14 13:48:08 "},"图解GoogleV8/11.html":{"url":"图解GoogleV8/11.html","title":"11 | 堆和栈：函数调用是如何影响到内存布局的？","keywords":"","body":"11 | 堆和栈：函数调用是如何影响到内存布局的？ // 在同一个任务中重复调用嵌套的foo函数 function foo() { foo()//堆栈溢出 } foo() // 使用setTimeout函数在不同的任务中执行 function foo() { setTimeout(foo, 0) } foo() // 在同一个任务中执行foo函数,但是却不是嵌套执行 function foo() { return Promise.resolve().then(foo) } foo() 为什么使用栈结构来管理函数调用? 函数可以被调用; 具有作用域机制,所谓的作用域机制,是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离,在函数内部定义的变量我们称为临时变量,临时变量只能在函数中被访问,外部函数通常无权访问,当函数执行结束之后,存放在内存中的临时变量也随之被销毁 栈如何管理函数调用? 函数在执行过程中,其内部的临时变量回按照执行顺序被压入到栈中. 一个函数的起始位置被称为栈桢指针 每个栈帧都对应着一个未运行完的函数,栈帧中保存了该函数的返回地址和局部变量 栈的优势 栈的结构和非常适合函数调用过程 在栈上分配资源和销毁咨询的速度非常快,这主要归结于栈空间是连续的,分配空间和销毁空间只需要移动下指针就可以了 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-14 14:16:26 "},"图解GoogleV8/12.html":{"url":"图解GoogleV8/12.html","title":"12 | 延迟解析：V8是如何实现闭包的？","keywords":"","body":"12 | 延迟解析：V8是如何实现闭包的？ 在编译js代码的时候,v8并不会一次性将所有的js解析为中间代码,这主要是基于以下两点: 如果一次编译所有的代码,会增加编译时间,这会严重影响到首次执行js代码的速度,让用户感觉到卡顿, 解析完成的字节码和编译之后的机器代码都会存在内存中,如果一次性解析和编译完成,那么中间代码和机器代码将会一直占用内存 因此,所有的js虚拟机都实现了惰性解析,所谓的惰性解析是指解析器在解析的过程中,如果遇到函数声明,那么会跳过函数内部的代码,并不会为其生成ast和字节码,而仅仅生成顶层代码的ast和字节码 闭包的三个特性 js允许在函数内部定义新的函数 可以在内部函数中访问父函数中定义的变量 函数可以作为另一个函数的返回值 v8还提供了另一个功能,就是函数的预解析. 在预解析的时候检查语法错误,见擦函数内部是否引用了外部变量,如果引用了外部变量,预解析器会将栈中的变量复制到堆中,在下次执行到该函数的时候,直接使用堆中的引用,这样就解决了闭包带来的问题 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-14 15:14:26 "},"图解GoogleV8/13.html":{"url":"图解GoogleV8/13.html","title":"13 | 字节码（一）：V8为什么又重新引入字节码？","keywords":"","body":"13 | 字节码（一）：V8为什么又重新引入字节码？ 字节码的作用 解释器可以直接解释执行字节码 优化编译器可以将字节码编译成二进制代码,然后在执行二进制代码 字节码如何提升代码的启动速度 减少了编译的时间,这是因为生成机器代码比生成字节码需要花费更久的时间,但是直接执行机器代码却比没事执行字节码更高效 字节码如何降低代码的复杂度 因为字节码的执行过程和CPU执行二进制代码的过程类似,形似的执行流程,那么将字节码转换为不同架构的二进制代码的工作量也会大大降低,这就降低了转换底层代码的工作量 字节码的优势 解决启动问题:生成字节码的时间很短 解决空间问题:字节码占用内存不多,缓存字节码会大大降低内存的使用 代码架构清晰:采用字节码,可以简化程序的复杂度,使得v8移植到不同的cpu架构平台更加容易 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-15 15:33:42 "},"图解GoogleV8/14.html":{"url":"图解GoogleV8/14.html","title":"14｜字节码（二）：解释器是如何解释执行字节码的？","keywords":"","body":"14｜字节码（二）：解释器是如何解释执行字节码的？ 字节码的解释执行在编译流水线中的位置如下图 如何生成字节码? function add(x,y){ var z= x+y return z } console.log(add(1,2)) 解析过程如下 因为解释器就是模拟物理机器来执行字节码的,比如可以实现如取指令,解析指令,执行指令,存储数据等,所以解释器的执行架构和cpu处理机器代码的架构类似. 通常有两种类型的解释器 基于栈,基于栈的解释器使用栈来保存函数参数,中间运算结果,变量等 基于寄存器的虚拟机则支持寄存器的指令操作,使用寄存器来保存参数,中间计算结果 基于寄存器的解释器架构,具体可参考如下 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-15 16:12:46 "},"图解GoogleV8/15.html":{"url":"图解GoogleV8/15.html","title":"15 | 隐藏类：如何在内存中快速查找对象属性？","keywords":"","body":"15 | 隐藏类：如何在内存中快速查找对象属性？ 什么是隐藏类 V8对每个对象都做了如下两点假设 对象创建好了之后就不会添加新的属性 对象创建好了之后也不会删除属性 V8为每个对象都创建了一个隐藏类,对象的隐藏类中记录了该对象一些基础的布局信息,包括 对象中所包含的所有的属性 每种类型像对于对象偏移量 多个对象公用一个隐藏类 减少隐藏类的创建次数,也间接加速了代码的执行速度 减少了隐藏类的存储空间 什么情况下两个对象的形状是相同的,要满足以下两点: 相同的属性名称 相等的属性个数 最佳实践: 使用字面量初始化对象时,要保证属性数据的一致性 尽量使用字面量一次性初始化完成对象属性 尽量避免使用delete方法 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-15 17:11:49 "},"图解GoogleV8/16.html":{"url":"图解GoogleV8/16.html","title":"16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？","keywords":"","body":"16 | 答疑： V8是怎么通过内联缓存来提升函数执行效率的？ 什么是内联缓存(IC) 内联缓存就是为每个函数添加了一个缓存,当第一次执行该函数时,v8会将函数中的存储,加载和调用相关的中间结果保存到反馈像向量中. 当再次执行时,v8就要去反馈向量中查找行管中间信息,如果命中了,那么就直接使用中间信息 一个反馈向量的一个插槽中可以包含多个隐藏类的信息 如果一个插槽中只包含1个隐藏类,那么我们称这种状态为单态 如果一个插槽中包含了2—4个隐藏类,那我们称这种状态为多态 如果一个插槽中超过4个隐藏类,那我们称这种状态为超类 函数的单一职责,也是同样的道理,如果函数的入参格式是固定的,那么就不会在反馈向量的隐藏类中存在多条信息,这样就避免了查找对比浪费的时间 function l(o) { return o.x } var o = {x:1,y:2} var o1 = {x:1,y:2,z:3} for (var i = 0;i 生成的隐藏类中包含如下信息: V8引入的ic,会监听每个函数的执行过程,并在一些关键的地方埋下监听点,这些包括了加载对象属性,给对象属性赋值,还有函数调用,v8会将监听到的数据写入一个称为反馈向量的结构中,同时v8会为每个执行的函数维护一个反馈向量,有了反馈向量混存的临时数据,v8就可以缩短对象属性的查找路径,从而提升执行效率 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-16 11:52:27 "},"图解GoogleV8/17.html":{"url":"图解GoogleV8/17.html","title":"17 | 消息队列：V8是怎么实现回调函数的？","keywords":"","body":"17 | 消息队列：V8是怎么实现回调函数的？ 什么是回调函数 回调函数其实也是一个函数,具有该函数的特性,他可以有参数和返回值,如果单独给出一个函数,你是看不出来它是不是回调函数的. 回调函数和普通函数的不同 主要在于它的调用方式,只有当某个函数被作为参数,传递给另外一个函数,或者传递给宿主环境,然后该函数放在函数内部或者宿主环境中被调用,我们称为回调函数 同步回调和异步回调的区别 同步回调函数是在执行函数内部被执行的,而异步回调函数是在执行函数外部被执行的 异步回调涉及消息队列和事件循环 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-16 14:04:05 "},"图解GoogleV8/18.html":{"url":"图解GoogleV8/18.html","title":"18 | 异步编程（一）：V8是如何实现微任务的？","keywords":"","body":"18 | 异步编程（一）：V8是如何实现微任务的？ 宏任务 指消息队列中等待被主线程执行的事件 调用栈是一种数据结构,用来管理在主线程上执行的函数的调用关系 微任务 指需要异步执行的函数,执行时机是在主函数执行结束之后,当前宏任务结束之前 微任务解决了宏任务执行世纪不可控的问题. 引入微任务主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗, 微任务技术栈:(消息队列,主线程,调用栈) 每个宏任务都会维护一个微任务队列 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-18 20:04:18 "},"常用工具/":{"url":"常用工具/","title":"常用工具","keywords":"","body":"常用工具 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "},"常用工具/00.html":{"url":"常用工具/00.html","title":"core-js 及垫片理念","keywords":"","body":"core-js 及垫片理念 core-js 是一个 JavaScript 标准库，它包含了 ECMAScript 2020 在内的多项特性的 polyfills，以及 ECMAScript 在 proposals 阶段的特性、WHATWG/W3C 新特性等 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:46:23 "},"常用工具/01.html":{"url":"常用工具/01.html","title":"Git 操作","keywords":"","body":"Git 操作 查看仓库的配置 git config --list --global(当前用户的所有仓库) git config --list --local(具体的某一个仓库) git config --list --system(对系统所有的登录的有效) 配置全局的 git 仓库 git config --global user.name \"Denise\" git config --global user.email 'deng.yanwen@icloud.com' 清除 git 配置 git config --unset --local user.name 建立 git 仓库 把已有的项目代码纳入 git 管理:git init 从远程新建项目, 然后 clone 下拉:git clone 修改之前的已提交的文件的名称 git mv readme readme.md 删除暂存区和本地工作目录的更改 git reset --hard 查看项目历史版本 git log --oneline(简洁的历史) git log -n2 --oneline git log --all (查看所有分支的提交历史) git 的核心对象:blob, tree, commit git cat-file -p , 查看 git 对象的内容 git cat-file -t , 查看 git 对象的类型 git cat-file -s , 查看 git 对象的大小 .git 文件中存放的内容 objects【文件夹】，存放所有的 git 对象，对象哈希值前两位是文件名，后 38 位作为对象文件名，可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看 HEAD 中存放指向当前分支所在的分支， config 当前 git 的配置文件 refs【文件夹】 heads 存放当前项目的所有分支 remotes 存放远程信息 tags 存放当前项目的所有分支 git branch -av 撤销操作 修改最后一次 commit 的信息：git commit --amend [danger] 注意: git log -p - 2: 查看最近两次提交历史的差异 git add -u: 将 git 已经跟踪的文件一起添加到暂存区 cp 原来的文件地址 需要拷贝到的地址: 拷贝文件 vi 文件名: 查看文件内容 mv 修改的文件的名称 改之后的文件名称 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 10:59:48 "},"常用工具/02.html":{"url":"常用工具/02.html","title":"本地仓库如何关联远程仓库","keywords":"","body":"本地仓库如何关联远程仓库 首先在远程仓库上建立一个空的项目 然后在本地新建一个项目，进入项目，执行命令git init,即为初始化本地的这个文件夹为一个git可以管理的仓库，这时候仓库会自动添加一个master分支 将本地仓库与远程仓库关联在一起，git remote add origin + 仓库地址 在新建本地代码之后，使用git push -u origin master将本地代码推送到远程仓库 [info] 注意:我们第一次push的时候,加上-u参数,Git就会把本地的master分支和远程的master分支进行关联起来,我们以后的push操作就不再需要加上-u参数了 之后就可以进行相关的代码操作了 [info] 注意：如果出现Git refusing to merge unrelated histories，解决方法为：git pull origin master后面跟上参数--allow-unrelated-histories Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 10:51:46 "},"日常总结/":{"url":"日常总结/","title":"日常总结","keywords":"","body":"日常总结 Copyright © 晨希 2021 all right reserved，powered by Gitbook该文章修订时间： 2021-01-11 09:37:57 "}}