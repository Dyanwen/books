# 模块化
> 模块化是一种将系统分离成独立功能部分的方法,可将系统分割成独立的功能部分,严格定义模块接口,模块间具有透明性

## 优点
- 解决命名冲突

- 提高代码复用性,方便模块间组合,分解

- 提高代码可维护性,

- 灵活架构,焦点分离

- 方便单个模块功能调试,升级

- 多人协作,互不干扰

- *高内聚*
    
>内聚度指模块内部实现,他是信息隐藏和局部话概念的自然扩展,它标志着一个模块内部各成分彼此结合的紧密程度,
    
    > 好处很明显,当把相关任务分组后去阅读就容易多了.设计时应该尽可能的提高模块的内聚度,从而获得较高的模块独立性


- *低耦合*
    
    > 耦合度则是指模块之间的关联程度的度量。耦合度取决于模块之间接口的复杂性，进入或调用模块的位置等。与内聚度相反，在设计时应尽量追求松散耦合的系统。

## 立即执行函数

> 通过函数作用域解决命名冲突,污染全局作用域的问题

## AMD&&CMD

> amd:同步加载代码,等所有的模块全部加载完成,才执行下面的代码

```js
define(['./a','./b'],function(a,b){
	a.do()
	b.do()
})
```

> cmd:异步加载模块

```js
define(function(require,exports,module){
	var a = require('./a')
	a.do()
})
```

## CommonJS

> exports和module.exports用法相似,exports是对module.exports的引用,不能直接对exports直接赋值

```js
exports.a = 1;
module.exports = {
	a:1,
	b:2
}
```

## ES Module

可以用于tree shaking



> 注意点⚠️
>
> - CommonJS支持动态导入,也就是`require(${path}/xx.js)`,esm不支持
> - CommonJS是同步导入的,因为用于服务端,文件都在本地,同步导入即使卡住主线程影响也不大,而esm是异步导入,因为用于浏览器,需要下载文件,如果也采用同步导入会对渲染有很大影响
> - CommonJS在导出时都是值拷贝,就算导出的值变了,导入的值也不会变,所以如果想更新值,必须重新导入一次,但是esm采用实时绑定的方式,导入导出的值都指向同一个内存地址,所以导入值会随着导出值变化
> - esm会编译成require/export来执行



