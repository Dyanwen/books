## 01 | delete 0：JavaScript中到底有什么是可以销毁的
---
表达式的值,在es的规范中,称为引用

```js
 delete 0
```
单值表达式的运算结果返回那个“对象字面量”的单值

delete x归根结底是在删除一个表达式的,引用类型的结果,而不是在删除x表达式,或者这个删除表达式的值

- delete 运算符尝试删除值数据时,会返回true,用于表示没有错误
- delete 0的本质时删除一个表达式的值
- delete x与delete 0 的区别只在于result是一个引用
- delete 其实只能删除一种引用,即对象的成员

> delete x中,如果x根本不存在,会发生什么?
返回true

> delete object.x中,如果x是只读的,会发生什么?
返回false,若是严格模式会报错


## 02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质
---

这行代码会泄漏一个全局变量y

- var 等声明语句总是在变量作用域或词法作用域中静态地声明一个或多个标识符.
- 全局变量的管理范式决定了“向一个不存在的变量赋值”所导致的变量泄漏是不可避免的
- 动态添加的“var声明”是可以删除的,这是唯一能操作varNames列表的方式
- 变量声明在引擎的处理上被分成了两部分,一部分是静态的,基于标识符的词法分析和管理,他总是在相应上下文的环境构建时作为名字创建的,另一部分是表达式执行过程,对上述名字的赋值,这个过程也称为绑定
> 不能删除var声明的变量,但是可以删除不实用var声明的全局变量


## 03 | a.x = a = {n/2}：一道被无数人无数次地解释过的经典面试题
---
```js
var a = {n:1}
a.x = a = {n:2}
console.log(a.x)//undefined
console.log(a) // { n: 2 }
```
这是因为首先在访问a.x的时候,将{n:1}赋值给了a.x,然后又重新给a赋了新值,所以导致之前赋值的a.x丢失

js权威指南中声明:js总是严格按照从左到右的顺序来计算表达式

```js
with只指定属性查找的优先级,所以with里面的x=100还是会泄漏到全局
```
## 04 | export default function() {}：你无法导出一个匿名函数表达式
---
es6的模块是静态配置的
传统的node.js模块却是动态加载的
```js
//导出值
export default <expression>
//导出声明的名字
export <let/const/var> x
//导出其他模块的名字
export ... from ...
```
一个export可以理解为如下两个步骤:
- 导出一个名字
- 为上述名字绑定一个值

export default function() {}并不是导出一个匿名函数表达式,而是导出一个匿名函数定义

## 05 | for (let x of [1,2,3]) ...：for循环并不比使用函数递归节省开销
---
switch的性能要高于if,是因为switch语句只有一个作用域,无法访问到外部声明的变量
```js
var a = '111',c = 1;
switch (c) {
	case 1:
		console.log(a);
		break;
	case 2:
		let a='22';
			break;Ï
	default:
		break;
}
```

所有在语句内可以存在的东西只有四种:表达式,其他语句,标识符声明和一种特殊的语法元素

变量作用域:var和函数声明
词法作用域:其他情况下的标识符和变量声明

单语句不支持词法声明
```
for (let i =0;i<5;i++) let i= 6;
```
这是因为单语句没有块级作用域,而词法声明是不可覆盖的,单语句后面的词法声明会存在潜在的冲突

因为在es6中,只要使用了大括号,就代表着块级作用域,所以不管是用let还是var,一定是会创建相应的循环数量的块级作用域的
如果不使用大括号,在for中使用let,也会创建相应循环数量的块级作用域.
也就是说,可以提高性能的唯一情况只有,循环体是单行语句就不使用大括号且for中使用var

## 06 | x/ break x;  搞懂如何在循环外使用break，方知语句执行真解
---

