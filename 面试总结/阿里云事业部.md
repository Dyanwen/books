- 原型的继承方式

  - prototype
  
- es6 class转换成es5的代码是什么

  - class中声明的变量和方法,会添加在构造函数的prototype上
  
- Es6,es7,es8的新特性都有哪些

  - 
  
- 闭包是什么

  - 闭包是指有权访问另外一个函数作用域中的变量的函数,本质是当前函数存在指向父级作用域的引用
  - 如果外部没有对闭包的引用,就会被垃圾回收机制回收
  
- 垃圾回收机制

  - 标记清除
    - 当变量进入执行环境时标记为“进入环境”，
    - 当变量离开执行环境时则标记为“离开环境”，
    - 被标记为“进入环境”的变量是不能被回收的，
    - 因为它们正在被使用，而标记为“离开环境”的变量则可以被回收
  - 引用计数
    - 统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收
    - 循环引用的变量需要手动释放
  
- 单例模式是什么,解决了什么问题

  - 单例模式是指在内存中只会创建且仅创建一次对象的设计模式,在程序中多次使用同一个对象且作用相同时，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象
  - 为了防止频繁地创建对象使得内存飙升, 并且在减少全局的函数和变量冲突也具有重要的意义
  
- vue diff算法

  - 
  
- redux,vuex的核心思想是什么,如何驱动视图的更新

  - Redux 和 Vuex 是基于 Flux 的，Redux 较为泛用，Vuex 只能用于 vue
  - Redux 中引入了中间件，主要解决异步带来的副作用，可通过约定完成许多复杂工作

- 状态码有哪些

- 输入地址到渲染发生了什么

- 跨域的几种方式

  - 使用cors,设置**access-control-allow-origin**为*
  - jsonp
    - 全局声明一个用来处理返回值的函数 fn，该函数参数为请求的返回结果
    - 将函数名与其他参数一并写入 URL 中
    - 创建一个 script 标签，把 URL 赋值给 script 的 src
  
- 模块化的组织方式,模块化解决方案

  - 一个文件一个模块,按文件划分模块
  - 使用立即执行函数表达式
  - esm
  - commonjs
  
- 重排重绘

- 浏览器缓存

  - 协商缓存
    - 在首次请求的时候,会返回最后的修改时间,添加到Last-Modified,当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的修改时间，这个请求头叫 If-Modified-Since
    - 还有一种依赖于文件哈希值的判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match,如果文件没有更改,则返回返回 304 Not Modified
  - 强制缓存
    - 在响应头部设置字段Expires来设置缓存时间,它对应一个未来的时间戳,客户端第一次请求的时候,服务端会在响应头部添加Expires字段.当再次请求的时候会先对比当前时间和Expires对应的时间,如果当前时间早于Expires时间,那么直接使用缓存,反之,需要再次发送请求
    - Cache-Control里面添加max-age最长有效时间,此处的优先级高于Expires
  
- webpack的优化

- 性能优化

  - 减少http请求
  - 使用服务端渲染
  - 合理的利用缓存
  - 静态资源使用cdn
  - 将css放在头部,js放在尾部
  - 使用字体图标代替图片
  - 压缩文件
  - 图片优化
    - 图片延迟加载
    - 响应式图片
    - 调整图片大小
    - 降低图片质量
    - 尽可能使用css3效果代替图片
  - 减少重排重绘
  - 使用事件委托
  - 如果判断有多个的话,可以使用switch替代if else,或者使用数组存储直接使用下表访问,或者通过对象存储
  - 尽量使用css样式的继承,不用将css嵌套层级太深,使用flex布局,代替float布局

  /////////////////////////////////////////////////////////////////////////////////////////////

首评秒开的四大保障
1. 懒加载
2. 使用缓存：接口数据缓存，静态资源缓存，协商缓存，强缓存，
3. 离线话
4. 并行化：因为http请求的限制，可以使用http2.x或者
  
- 快排

- 前端的攻击方法

- 工程化,组件化,模块化

  - 工程化

    - 开发效率

      - Mork工具的使用

      - 使用预处理语言和预处理器

      - 开发工具的使用

      - 构建工具的使用

        - Gulp 在处理任务的过程中基于 NodeJS 的数据流,本质上是操读写内存，而 Grunt 则是基于临时文件

- vue相比于原生的优势在哪里

  - vue是响应式编程,数据和页面分离,虚拟dom,运行速度快
  - 数据驱动视图
  - 页面传参和页面状态管理
  - 模块化开发,无刷新场景参数更新
  - 代码的可读性更高
  - 基于强大的nodejs,又丰富的npm包管理
  - 各组件样式不冲突
  - 组件化
  
- 全局变量和单例模式有什么区别?
  - 全局变量是对一个对象的静态引用,全局变量确实可以提供单例模式实现的全局访问功能,但是它并不能保证应用程序只有一个实例,编码规范明确指出应该减少使用全局变量,因为过多的使用全局变量会造成代码难读,全局变量并不能实现继承
  - 单例模式虽然在继承上不能很好的处理,但是还是可以实现继承的,单例模式在类中保存了它的唯实例这个类,可以保证只能创建一个实例,同时他还提供了一个访问该唯一实例的全局访问点
  
- vuex的实现原理是什么
  
  - vuex实现的原理是callback的形式,没有使用eventEmit
  - 因为使用callback的形式,只能绑定一个执行函数
  - 而使用eventEmit可以绑定多个事件
  - 都是通过key:value的形式绑定,但是eventEmit维护的是一个数组
  
- 微服务是如何做到沙箱数据隔离的?

- react-router中link标签和a标签的区别

  从最终渲染的 DOM 来看，这两者都是链接，都是 `<a>` 标签，区别是：
  `<Link>` 是 react-router 里实现路由跳转的链接，一般配合 `<Route>` 使用，react-router 接管了其默认的链接跳转行为，区别于传统的页面跳转，`<Link>` 的“跳转”行为只会触发相匹配的 `<Route>` 对应的页面内容更新，而不会刷新整个页面。
  而 `<a>` 标签就是普通的超链接了，用于从当前页面跳转到 href 指向的另一个页面（非锚点情况）。

