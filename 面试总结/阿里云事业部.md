- 原型的继承方式

  - prototype

- es6 class转换成es5的代码是什么

  - class中声明的变量和方法,会添加在构造函数的prototype上

- Es6,es7,es8的新特性都有哪些

  - 

- 闭包是什么

  - 闭包是指有权访问另外一个函数作用域中的变量的函数,本质是当前函数存在指向父级作用域的引用
  - 如果外部没有对闭包的引用,就会被垃圾回收机制回收

- 垃圾回收机制

  - 标记清除
    - 当变量进入执行环境时标记为“进入环境”，
    - 当变量离开执行环境时则标记为“离开环境”，
    - 被标记为“进入环境”的变量是不能被回收的，
    - 因为它们正在被使用，而标记为“离开环境”的变量则可以被回收
  - 引用计数
    - 统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收
    - 循环引用的变量需要手动释放

- 单例模式是什么,解决了什么问题

  - 单例模式是指在内存中只会创建且仅创建一次对象的设计模式,在程序中多次使用同一个对象且作用相同时，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象
  - 为了防止频繁地创建对象使得内存飙升, 并且在减少全局的函数和变量冲突也具有重要的意义

- vue diff算法

  - 

- redux,vuex的核心思想是什么,如何驱动视图的更新

- 状态码有哪些

- 输入地址到渲染发生了什么

- 跨域的几种方式

  - 使用cors,设置**access-control-allow-origin**为*
  - jsonp
    - 全局声明一个用来处理返回值的函数 fn，该函数参数为请求的返回结果
    - 将函数名与其他参数一并写入 URL 中
    - 创建一个 script 标签，把 URL 赋值给 script 的 src

- 模块化的组织方式,模块化解决方案

  - 一个文件一个模块,按文件划分模块
  - 使用立即执行函数表达式
  - esm
  - commonjs

- 重排重绘

- 浏览器缓存

  - 协商缓存
    - 在首次请求的时候,会返回最后的修改时间,添加到Last-Modified,当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的修改时间，这个请求头叫 If-Modified-Since
    - 还有一种依赖于文件哈希值的判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match,如果文件没有更改,则返回返回 304 Not Modified
  - 强制缓存
    - 在响应头部设置字段Expires来设置缓存时间,它对应一个未来的时间戳,客户端第一次请求的时候,服务端会在响应头部添加Expires字段.当再次请求的时候会先对比当前时间和Expires对应的时间,如果当前时间早于Expires时间,那么直接使用缓存,反之,需要再次发送请求
    - Cache-Control里面添加max-age最长有效时间,此处的优先级高于Expires

- webpack的优化

- 性能优化

  - 减少http请求
  - 使用服务端渲染
  - 合理的利用缓存
  - 静态资源使用cdn
  - 将css放在头部,js放在尾部
  - 使用字体图标代替图片
  - 压缩文件
  - 图片优化
    - 图片延迟加载
    - 响应式图片
    - 调整图片大小
    - 降低图片质量
    - 尽可能使用css3效果代替图片
  - 减少重排重绘
  - 使用事件委托
  - 如果判断有多个的话,可以使用switch替代if else,或者使用数组存储直接使用下表访问,或者通过对象存储
  - 尽量使用css样式的继承,不用将css嵌套层级太深,使用flex布局,代替float布局

- 快排

- 前端的攻击方法

- 工程化,组件化,模块化

  - 工程化

    - 开发效率

      - Mork工具的使用

      - 使用预处理语言和预处理器

      - 开发工具的使用

      - 构建工具的使用

        - Gulp 在处理任务的过程中基于 NodeJS 的数据流,本质上是操读写内存，而 Grunt 则是基于临时文件

          

- vue相比于原生的优势在哪里

  - vue是响应式编程,数据和页面分离,虚拟dom,运行速度快

  - 组件化

    