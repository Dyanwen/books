## 01.算法与数据结构

- 修炼内功
- 进大厂的必要条件
- 算法和数据结构是有趣并且实用的

## 02.如何事半功倍的学习算法与数据结构

> 《异类-不一样的成功启示录》

- 切碎知识点
- 刻意练习
- 反馈
- 切题四件套
  - 明确题目的意思
  - 列举所有可能的情况,最优解
  - 多写
  - 测试 case

## 04 - 如何通过 LeetCode 来进行算法题目练习

- 坚持,刻意练习
- 练习缺陷,弱点的地方
- 不舒服,不爽,枯燥

## 05 - 理论讲解：数组&链表

### 数组:内存中一段连续的存储区域

- 查找的时间复杂度为 O(1)
- 插入的时间复杂度为 O(n)
- 删除的时间复杂度为 O(n)

### 链表:数组的改善

#### 使用情况如下

- 频繁的插入或者删除
- 不知道有多少元素在,每次来一个元素就插入一个元素在后面

#### 时间复杂度

- 查找的时间复杂度为 O(n)
- 插入的时间复杂度为 O(1)
- 删除的时间复杂度为 O(1)

## 07 - 理论讲解：堆栈&队列

### stack:先进后出(FILO)

### queue:先进先出(FIFO)

## 10 - 理论讲解：优先队列

### 实现原理

- 堆(二叉堆,多项式堆,斐波那契堆)
- 二叉搜索树

### 17 - 理论讲解：树&二叉树&二叉搜索树

> Linked List(链表) 就是特殊化的 Tree(树)
> Tree(树) 就是特殊化的 Graph(图)

二叉搜索树:也称二叉搜索树.有序二叉树,排序二叉树,是指一个空树或者具有下列性质的二叉树:

- **左子树**上所有节点的值均小于它的根节点的值
- **右子树**上所有节点的值均大于大的根节点的值
- Recursively(递归),左右子树也分别为二叉查找树

## 20 - 理论讲解：二叉树遍历

**前/中/后序遍历**用的比较少,主要就是 root 节点的位置

**广度/深度优先搜索**用的比较多

## 24- 贪心算法

贪心法:又称贪心算法,贪婪算法,在对问题求解时,总是做出在当前看来是最好的选择

适合用 Greedy 的场景

简单的说,问题能够分解成子问题来解决,子问题的最优解能够递推到最终问题的最优解,这种子问题最优解成为最优子结构

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择,不能回退.动态规划则会保存以前的运算结果,并根据以前的结果对当前进行选择,有回退功能

## 30-剪枝

## 36-字典树

Trie 树,即字典树,又称单词查找树或键树,是一种树形结构,是一种哈希树的变种.典型应用就是用于统计和排序大量的字符串,所以经常被搜索引擎系统用于文本词频统计

它的优点是:最大限度的减少所谓的字符串比较,查询效率比哈希表高

### 核心思想:空间换时间

利用字符串的公共前缀来降低查询时间的开销以达到提交效率的目的

### 基本性质

- 根节点不包含字符,除根节点外每个节点都只包含一个字符
- 从根节点到某一节点,路径上经过的字符连接起来,为该节点对应的字符串
- 每个节点的所有子节点包含的字符都不相同

## 39-位运算

### 位运算的介绍

程序中的所有数载计算机内存中都是以二进制的形式存储的.位运算说穿了就是直接对整数在内存中的二进制位进行操作

由于位运算直接对内存数据进行操作,不需要转成十进制,因此处理速度非常快

### 位运算常用操作

| 符号 | 描述 |                                             运算规则                                             |
| :--: | :--: | :----------------------------------------------------------------------------------------------: |
|  &   |  与  |                                   两个位数都为 1 时,结果才为 1                                   |
|  \|  |  或  |                                   两个位数都为 0 时,结果才为 0                                   |
|  ^   | 异或 |                                    两个单位相同为 0,不同为 1                                     |
|  ~   | 取反 |                                        0 变成 1,1 变成 0                                         |
|  <<  | 左移 |                             各二进位全部左移若干位,高位丢弃,低位补 0                             |
|  >>  | 右移 | 各二进制全部右移若干位,对无符号数,高位补 0,有符号数,各编译器处理方法不一样,有的补符号位,有的补 0 |

XOR-异或

> 异或:相同位 0,不同为 1,也可用[不进位加法]来理解

```js
x^0 = 0
x^1s = ~x // 1s = ~0
x^ (~x ) = 1s
x^x=0
a^b = c =>a^c = b,b^c= a//swap
a^b^c = a^(b^c) = (a^b)^c

```

### 位运算的应用

实战常用的位运算操作

- x & 1 == 1 or ==0 判断奇偶(x%2==1)
- x = x & (x-1)=>清零最低位的 1
- x & -x =>得到最低位的 1

1. 将 x 最右边的 n 为清零 `x&(~0<<n)`
2. 获取 x 的第 n 位值(0 或者 1)`(x>>n)&1`
3. 获取 x 的第 n 位的幂值`x&(1<<(n-1))`
4. 仅将第 n 位置为 1`x|(1<<n)`
5. 仅将第 n 位置为 0`x&(~(1<<n))`
6. 将 x 最高位至第 n 位清零`x&((1<<n)-1)`
7. 将第 n 位至第 0 位(含)清零`x&(~((1<<(n+1))-1))`

## 45.动态规划(上)

1. 递归+记忆化 =》递推
2. 状态的定义:opt[n],dp[n],fib[n]
3. 状态转移方程:opt[n] = best_of(opt[n-1],opt[n-2],...)
4. 最优子结构

## 46.动态规划(下)

DP vs 回溯 vs 贪心

- 回溯(递归)-重复计算
- 贪心-永远局部最优
- DP-记录局部最优子结构/多种记录值

## 58 - 课程重点回顾

- 
